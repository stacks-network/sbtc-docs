<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sBTC Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction to sBTC</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guides</li><li class="chapter-item expanded "><a href="how-to-deposit-and-withdraw.html"><strong aria-hidden="true">2.</strong> How to Deposit and Withdraw</a></li><li class="chapter-item expanded "><a href="how-to-stacker.html"><strong aria-hidden="true">3.</strong> How to Participate as a Stacker</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guides</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">4.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="local-setup.html"><strong aria-hidden="true">5.</strong> Local Environment Setup</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">6.</strong> End to End Tutorial</a></li><li class="chapter-item expanded "><a href="deposit.html"><strong aria-hidden="true">7.</strong> Initiating a Deposit</a></li><li class="chapter-item expanded "><a href="withdrawal.html"><strong aria-hidden="true">8.</strong> Initiating a Withdrawal</a></li><li class="chapter-item expanded "><a href="sbtc-sdk.html"><strong aria-hidden="true">9.</strong> The sBTC SDK</a></li><li class="chapter-item expanded affix "><li class="part-title">Signer Guides</li><li class="chapter-item expanded "><a href="how-to-signer.html"><strong aria-hidden="true">10.</strong> How to Operate a Signer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developer-release-signer.html"><strong aria-hidden="true">10.1.</strong> Developer Release</a></li><li class="chapter-item expanded "><a href="nakamoto-signer-developer-guide.html"><strong aria-hidden="true">10.2.</strong> Nakamoto Release</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">sBTC Design</li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">11.</strong> Architecture Overview</a></li><li class="chapter-item expanded "><a href="sbtc-operations.html"><strong aria-hidden="true">12.</strong> sBTC Requests and Responses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sbtc-operations/bitcoin-transactions.html"><strong aria-hidden="true">12.1.</strong> Bitcoin Transactions</a></li><li class="chapter-item expanded "><a href="sbtc-operations/commit-reveal-system.html"><strong aria-hidden="true">12.2.</strong> The Commit-Reveal System</a></li><li class="chapter-item expanded "><a href="clarity-contracts.html"><strong aria-hidden="true">12.3.</strong> Clarity Contracts</a></li></ol></li><li class="chapter-item expanded "><a href="stacker-responsibilities.html"><strong aria-hidden="true">13.</strong> Stacker responsibilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stacker-responsibilities/frost.html"><strong aria-hidden="true">13.1.</strong> Signature Aggregation with FROST</a></li><li class="chapter-item expanded "><a href="stacker-responsibilities/wsts-adaptation.html"><strong aria-hidden="true">13.2.</strong> WSTS Adaptation</a></li><li class="chapter-item expanded "><a href="stacker-responsibilities/signing-protocol.html"><strong aria-hidden="true">13.3.</strong> Signing Protocol</a></li><li class="chapter-item expanded "><a href="stacker-db.html"><strong aria-hidden="true">13.4.</strong> StackerDB</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">sBTC Releases</li><li class="chapter-item expanded "><a href="sbtc-releases.html"><strong aria-hidden="true">14.</strong> sBTC Releases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sbtc-releases/sbtc-dev.html"><strong aria-hidden="true">14.1.</strong> sBTC 0.1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sbtc-releases/sbtc-dev/faq.html"><strong aria-hidden="true">14.1.1.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="sbtc-releases/sbtc-dev/limitations.html"><strong aria-hidden="true">14.1.2.</strong> Known Limitations</a></li></ol></li><li class="chapter-item expanded "><a href="sbtc-releases/sbtc-nakamoto.html"><strong aria-hidden="true">14.2.</strong> sBTC 1.0</a></li><li class="chapter-item expanded "><a href="sbtc-releases/sbtc-nakamoto-v2.html"><strong aria-hidden="true">14.3.</strong> sBTC 1.1</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sBTC Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the sBTC developer documentation.</p>
<p>Here you will find the most up-to-date description of what sBTC is, how it's implemented and how you can get involved.</p>
<p>For deep technical dive into the sBTC system in its entirety, we recommend reading the <a href="https://github.com/stacksgov/sips/blob/31dae06bc9c18fa4a7ef43cf7387e83a650228f6/sips/sip-025/sip-025-sbtc.md">proposed SIP</a> as well.</p>
<h1 id="introduction-to-sbtc"><a class="header" href="#introduction-to-sbtc">Introduction to sBTC</a></h1>
<p>To understand sBTC, we first need to understand the current limitations of Bitcoin (BTC).</p>
<p>Bitcoin is to date the most secure and decentralized blockchain.
While Bitcoin is the largest cryptocurrency by market cap, comparatively few applications exist within the Bitcoin ecosystem.
Developers interested in building applications for the Bitcoin community often find it difficult or impossible to implement their logic directly on the Bitcoin chain.
Although Bitcoin has a simple scripting system built in, it lacks the expressiveness of many other smart contract languages.</p>
<p>sBTC is for:</p>
<ul>
<li>Bitcoin holders who want to participate in smart contracts.</li>
<li>Developers who want to build applications on Bitcoin.</li>
</ul>
<p>sBTC empowers developers to build applications on Bitcoin by bridging Bitcoin and <a href="https://www.stacks.co/">Stacks</a>.
We achieve this by introducing a fungible token (sBTC) on the Stacks blockchain.
The token has the following properties:</p>
<ul>
<li><strong>1:1 redeemability</strong>. sBTC can always be exchanged 1:1 for BTC on the Bitcoin chain, as long as the Stacks blockchain is operational.</li>
<li><strong>Open membership</strong>. Anyone can participate in the sBTC protocol. No centralized entity maintains custody over any BTC in the protocol.</li>
</ul>
<p>Other tokens which try to achieve the same end as sBTC are</p>
<ul>
<li><a href="https://www.stacks.co/blog/tokensoft-wrapped-fundamental-bitcoin-defi-building-blocks-xbtc">xBTC</a></li>
</ul>
<p>While these tokens all achieve the same value as BTC, they maintain BTC reserves through trusted entities.
sBTC is the only truly decentralized Bitcoin backed asset on Stacks.</p>
<h1 id="how-does-sbtc-work"><a class="header" href="#how-does-sbtc-work">How does sBTC work?</a></h1>
<p>Bitcoin holders can do two things to interact with sBTC, deposit and withdraw.
Both of these operations are controlled through special Bitcoin transactions.</p>
<p>To deposit BTC into sBTC, a Bitcoin holder would create a deposit transaction on the Bitcoin chain.
This deposit transaction informs the protocol how much BTC the holder has deposited, and to which Stacks address the holder wishes to receive the sBTC.
The sBTC system responds to the deposit transaction by minting sBTC to the given Stacks address.</p>
<p>To withdraw BTC, a Bitcoin holder creates a withdrawal transaction on the Bitcoin chain.
This withdrawal transaction informs the protocol how much sBTC the holder wishes to withdraw, from which stacks address the sBTC should be withdrawn and which Bitcoin address should receive the withdrawn BTC.
In response to this transaction, the sBTC system burns the requested amount of sBTC from the given Stacks address and fulfills the withdrawal by issuing a BTC payment to the given BTC address with the same amount.</p>
<p>The following diagram illustrates the deposit and withdrawal flows.</p>
<pre class="mermaid">sequenceDiagram
    Actor Bitcoin holder
    participant Bitcoin
    Actor sBTC Protocol
    participant Stacks

    Bitcoin holder -&gt;&gt; Bitcoin: Deposit transaction
    Bitcoin --&gt;&gt; sBTC Protocol: Read sBTC operations
    sBTC Protocol -&gt;&gt; Stacks: Mint sBTC

    Bitcoin holder -&gt;&gt; Bitcoin: Withdrawal transaction
    Bitcoin --&gt;&gt; sBTC Protocol: Read sBTC operations
    sBTC Protocol -&gt;&gt; Stacks: Burn sBTC
    sBTC Protocol -&gt;&gt; Bitcoin: Fulfill withdrawal
</pre>
<h1 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next?</a></h1>
<p>If you want to use sBTC as user, check out <a href="./how-to-deposit-and-withdraw.html">How to Deposit and Withdraw</a>.</p>
<p>If you're a developer looking to build applications with sBTC, check out the <a href="./quickstart.html">Quickstart</a>.</p>
<p>If you want to dive into the details and understand how sBTC achieves a secure open-membership wrapping of Bitcoin, look into the design documentation. A good start is the <a href="./architecture.html">Architecture Overview</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-deposit-and-withdraw"><a class="header" href="#how-to-deposit-and-withdraw">How to Deposit and Withdraw</a></h1>
<p>Depositing and withdrawing sBTC can be done in three ways:</p>
<ol>
<li>Using the <a href="https://bridge.stx.eco/">sBTC Bridge</a> application.</li>
<li>Using an sBTC enabled wallet.</li>
<li>Using an app which integrates with sBTC natively.</li>
</ol>
<p>This guide will walk you through how to deposit and withdraw sBTC using the sBTC Brdige application.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>First, make sure you have the <a href="https://wallet.hiro.so/">Hiro Wallet</a> browser extension installed.
Then, to begin your deposit or withdrawal, navigate to <a href="https://bridge.stx.eco/">https://bridge.stx.eco/</a>.
Once there, click the <code>Settings</code> dropdown and make sure you're on the right network.
Thereafter, you should select the appropriate transaction mode:</p>
<ul>
<li>If you want to deposit BTC from your Hiro Wallet, select <code>OP_RETURN</code>.</li>
<li>If you want to deposit BTC from a custodial wallet, select <code>OP_DROP</code>.</li>
</ul>
<p>With these settings in place, you may proceed to do your deposit or withdrawal.</p>
<h2 id="how-to-deposit"><a class="header" href="#how-to-deposit">How to Deposit</a></h2>
<p>To deposit you will be prompted to enter</p>
<ol>
<li>Your bitcoin address to deposit from.</li>
<li>A stacks address to receive the sBTC.</li>
<li>The amount to deposit.</li>
</ol>
<p>Once you have entered this information and continue, you will either be prompted to sign a transaction with the Hiro Wallet or receive a QR code to scan depending on your transaction mode.</p>
<p>When you have signed or paid to the QR code you'll get a link to follow your request on the Bitcoin chain. The sBTC should be minted shortly after your request is mined.</p>
<h2 id="how-to-withdraw"><a class="header" href="#how-to-withdraw">How to Withdraw</a></h2>
<p>To withdraw you will be prompted to enter</p>
<ol>
<li>Your bitcoin address to receive the BTC which is also used to request the withdrawal.</li>
<li>Your stacks address from which the sBTC should be withdrawn.</li>
<li>The amount to withdraw.</li>
</ol>
<p>You will then be prompted to sign a message payload with the Hiro Wallet to authenticate your request.
Once the request is authenticated you will be prompted to either sign a bitcoin transaction or receive a QR code to scan depending on your transaction mode.</p>
<p>When you have signed or paid to the QR code you'll get a link to follow your request on the Bitcoin chain. The sBTC should be burned shortly after your request is mined.
Thereafter, the system will wait until the sBTC burn is final before fulfilling your withdrawal on the Bitcoin chain. This may take up to 150 bitcoin blocks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-participate-as-a-stacker"><a class="header" href="#how-to-participate-as-a-stacker">How to Participate as a Stacker</a></h1>
<p>Participating as a Stacker in the Stacks Blockchain is an essential role to ensure the liveliness of sBTC. To become a Stacker, you must hold and temporarily lock STX, Stacks’ native currency, and support the network’s security and consensus. As a reward, you earn BTC.</p>
<p>There are multiple ways for you to stack and earn Bitcoin - either <a href="how-to-stacker.html#stacking-through-an-exchange">through an exchange</a>, a <a href="how-to-stacker.html#stacking-through-a-non-custodial-stacking-service">non-custodial stacking service</a>, or <a href="how-to-stacker.html#independent-stacking">independently</a>. The most appropriate choice depends on your crypto experience and the amount of STX you have at your disposal. For direct participation, Stacks holders need a dynamic minimum amount of STX (approximately 100,000k STX during the mainnet, but this amount fluctuates based on overall participation and supply. See the <a href="https://docs.hiro.so/api#tag/Info/operation/get_pox_info"><code>pox</code> endpoint</a> of the Hiro API to get the minimum of the next cycle). If you don't meet this minimum, you can still participate by leveraging third-party Stacking delegation services. These services combine your holdings with others, allowing joint participation. A complete breakdown of the stacking mechanism can be found in <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md">SIP-007</a>.</p>
<p>Below is a documentation guide that outlines the steps to participate as a Stacker in the Stacks blockchain network, along with the responsibilities and actions involved in the role. Options for stacking through an exchange a stacking service can be found on the <a href="https://www.stacks.co/learn/stacking#startstacking">stacks.co stacking page</a>.</p>
<h2 id="stacking-through-an-exchange"><a class="header" href="#stacking-through-an-exchange">Stacking Through an Exchange</a></h2>
<ol>
<li>
<p>Choose an Exchange
Select a reputable cryptocurrency exchange that offers Stacking services for STX.</p>
</li>
<li>
<p>Create an Account
If you don't have an account on the chosen exchange, sign up for one. Complete the necessary verification procedures.</p>
</li>
<li>
<p>Deposit STX
Deposit the desired amount of STX into your exchange account.</p>
</li>
<li>
<p>Navigate to Stacking Section
Go to the Stacking section or menu within the exchange platform.</p>
</li>
<li>
<p>Select Stacking Options
Choose the stacking options that suit your preferences, such as the duration and amount to be stacked.</p>
</li>
<li>
<p>Start Stacking
Confirm the stacking process on the exchange platform. Your STX will be locked for the chosen stacking period, and you'll start earning rewards. The exchange will fulfill your signing obligations on your behalf according to their own configurations.</p>
</li>
<li>
<p>Monitor Stacking Rewards
Keep track of your stacking rewards on the exchange platform. The rewards will typically be automatically credited to your account.</p>
</li>
</ol>
<h2 id="stacking-through-a-non-custodial-stacking-service"><a class="header" href="#stacking-through-a-non-custodial-stacking-service">Stacking Through a Non-Custodial Stacking Service</a></h2>
<ol>
<li>
<p>Choose a Non-Custodial Stacking Service
Research and select a reputable non-custodial Stacking stacking service that aligns with your preferences and goals.</p>
</li>
<li>
<p>Set Up a Stacks Wallet
Ensure you have a compatible Stacks wallet that supports Stacking. Examples include the Stacks Wallet or other wallets that are Stacking-enabled.</p>
</li>
<li>
<p>Acquire STX
Acquire the desired amount of STX to participate in the Stacking stacking service.</p>
</li>
<li>
<p>Register with the Stacking Service
Follow the registration process for the chosen stacking service. Provide the necessary details, including your wallet address.</p>
</li>
<li>
<p>Delegate Your STX
Delegate your STX holdings to the stacking service. This process allows the stacking service to participate in Stacking on your behalf while your STX remains under your control. The stacking service will fulfill your signing obligations on your behalf according to their own configurations.</p>
</li>
<li>
<p>Receive Stacking Rewards
As part of the stacking service, you'll receive Stacking rewards proportionate to your contribution. The rewards will typically be automatically distributed to your wallet by the stacking service operator.</p>
</li>
</ol>
<h2 id="independent-stacking"><a class="header" href="#independent-stacking">Independent Stacking</a></h2>
<ol>
<li>
<p>Set Up a Stacks Wallet
Choose a compatible Stacks wallet that supports Stacking. Download and install the wallet on your device.</p>
</li>
<li>
<p>Acquire STX
Acquire the dynamic minimum amount of STX required for independent Stacking. As of now, this amount is approximately 100,000k STX, but verify for any updates on this requirement.</p>
</li>
<li>
<p>Setup or Select a Signer
To fulfill your obligation to validate and sign sBTC transactions, you must first select or <a href="how-to-signer.html">setup a Signer</a></p>
</li>
<li>
<p>Register as a Stacker
After setting up your wallet and acquiring the required STX, register as a stacker on the Stacks Blockchain. The registration process may vary based on wallet providers.</p>
</li>
<li>
<p>Start Stacking
Once registered, your wallet will facilitate the process of participating in the Stacking consensus and validating transactions. You will earn STX rewards for your contributions to securing the network.</p>
</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Stacking in the Stacks Blockchain is a rewarding way to participate in the network's consensus and earn BTC rewards. Choose the method that aligns with your preferences, and always prioritize security when participating in Stacking. Remember to research the chosen exchange or stacking service and stay informed about any updates or changes to the Stacking process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>If you are a developer looking to start building with sBTC, this is the place to start.</p>
<h2 id="1-familiarize-yourself-with-sbtc"><a class="header" href="#1-familiarize-yourself-with-sbtc">1. Familiarize yourself with sBTC</a></h2>
<p>First, if you aren't familiar with what sBTC is or how it works, be sure to check out the <a href="./architecture">sBTC Design</a> documentation.</p>
<h2 id="2-learn-about-the-developer-release"><a class="header" href="#2-learn-about-the-developer-release">2. Learn about the Developer Release</a></h2>
<p>The <a href="./sbtc-releases/sbtc-dev.html">Developer Release</a> is the very first version of sBTC, and is designed to provide a preview version of sBTC for developers to learn and experiment with.</p>
<h2 id="3-get-setup-with-a-local-dev-environment"><a class="header" href="#3-get-setup-with-a-local-dev-environment">3. Get setup with a local dev environment</a></h2>
<p>Once you understand how it works and what the Developer Release is, it's time to get the sBTC development environment set up locally with the <a href="./local-setup.html">Local Setup Guide</a>.</p>
<h2 id="4-learn-sbtc-development"><a class="header" href="#4-learn-sbtc-development">4. Learn sBTC development</a></h2>
<p>Now it's time to get up and running with a complete full-stack sBTC-powered application. The <a href="./tutorial.html">End to End Tutorial</a> will teach you how to build an app using Next, Clarity, Stacks.js, and sBTC from start to finish.</p>
<h2 id="5-keep-going"><a class="header" href="#5-keep-going">5. Keep Going</a></h2>
<p>Now that you've got the basics down, you can refer to the <a href="./deposit.html">deposit</a> and <a href="./withdrawal.html">withdrawal</a> code examples for a quick reference on how to initiate deposits and withdrawals with Stacks.js and the Leather wallet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-started-with-sbtc-01-on-devnet"><a class="header" href="#get-started-with-sbtc-01-on-devnet">Get Started with sBTC 0.1 on devnet</a></h1>
<h2 id="local-setup"><a class="header" href="#local-setup">Local setup</a></h2>
<p>Devnet is a setup with a local bitcoin node running regtest, a local stacks node running testnet and connecting to the local bitcoin node. In addition, explorers and api servers are setup to provide easy access to information.</p>
<p>Developers should use docker to setup all required services.</p>
<p>Here are the basic steps we'll need to follow to get everything running.</p>
<ol>
<li>Launch devnet.</li>
<li>Deploy sbtc contract (happens automatically).</li>
<li>Launch sBTC binary (Alpha romeo engine).</li>
<li>Use sBTC web app (sBTC Bridge) or sbtc cli or your own app.</li>
</ol>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li>Install <a href="https://docs.docker.com/engine/install/">Docker</a>.</li>
<li>Install <a href="https://github.com/hirosystems/clarinet">Clarinet</a> (version 1.7.0 or higher).</li>
</ul>
<h2 id="launch-devnet"><a class="header" href="#launch-devnet">Launch Devnet</a></h2>
<p>We'll get sBTC up and running locally using the <a href="https://github.com/stacks-network/sbtc/blob/main/devenv/README.md">sBTC devenv</a>. You'll need to make sure you have Docker and Docker Compose installed on your system.</p>
<p>First, make sure you have the <a href="https://github.com/stacks-network/sbtc"><code>sbtc</code></a> repo cloned locally.</p>
<p>Now let's get everything running. Make sure you are in the <code>devenv</code> folder and run:</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<p>This first build will take a while to complete, but once that's done we just need to run everything with:</p>
<pre><code class="language-bash">./up.sh
</code></pre>
<p>Let's check to make sure things are running by visiting the Stacks explorer and the Bridge app. The Stacks explorer will take a bit get up and running.</p>
<ul>
<li><a href="http://127.0.0.1:3020/?chain=testnet&amp;api=http://127.0.0.1:3999">http://127.0.0.1:3020/?chain=testnet&amp;api=http://127.0.0.1:3999</a> (Stacks explorer)</li>
<li><a href="http://127.0.0.1:8083">http://127.0.0.1:8083</a> (Bitcoin explorer)</li>
<li><a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a> (sBTC Bridge App)</li>
</ul>
<h2 id="deploy-contracts"><a class="header" href="#deploy-contracts">Deploy Contracts</a></h2>
<p>The deployment of the Clarity contracts <code>asset.clar</code> and <code>clarinet-bitcoin-mini.clar</code> happens during the launch of devenv.sbtcWalletAddress</p>
<p>Under the hood, there is a script <code>utils/deploy_contracts.sh</code> that is used to deploy the contracts The local environment defines wallets that are already funded. The deployer wallet is used to deploy the contract using clarinet deployments.</p>
<h2 id="prepare-wallet"><a class="header" href="#prepare-wallet">Prepare Wallet</a></h2>
<p>You can take a look at the config file at <code>sbtc/devenv/sbtc/docker/config.json</code> to see the mnemonic that defines the taproot address that will be the contract owner for sBTC. This is the mnemonic that generates the address that will actually call the <code>mint</code> function in the sBTC contract.</p>
<p>If you take a look at the <code>sbtc/romeo/asset-contract/settings/Devnet.toml</code> you can see this mnemonic associated with a specific Stacks address. This will also be the address that will be used to deploy the actual contracts.</p>
<p>Download the <a href="https://leather.io">Leather wallet</a> (version 6.11.+) and import the deployer address mnemonic into it to load that account locally.</p>
<pre><code>twice kind fence tip hidden tilt action fragile skin nothing glory cousin green tomorrow spring wrist shed math olympic multiply hip blue scout claw
</code></pre>
<p>You can see more default generated mnemonics for the devnet in the <a href="https://github.com/stacks-network/sbtc/devenv"><code>devenv</code> repo</a>.</p>
<p>In Leather wallet, you see that Account 1 is the deployer. Nevertheless, you can use this account or Account 2 as a normal user.</p>
<h2 id="mint-some-btc-and-sbtc"><a class="header" href="#mint-some-btc-and-sbtc">Mint some BTC and sBTC</a></h2>
<p>There are helper scripts to create and broadcast deposit and withdrawal requests. They are contained in the <code>utils</code> folder of devenv:</p>
<ol>
<li>mint_btc.sh: funds the btc addresses with BTC. Add the number of blocks to mint for the two addresses as parameter.</li>
<li>deposit.sh: deposits a random amount of less than 10,000 sats. sBTC will be received by the deployer stacks address.</li>
<li>withdrawal.sh: withdraws a random amount of less than 2,000 sats.</li>
</ol>
<p>Before running these, make sure the Stacks devnet is running by visiting the explorer at <a href="http://127.0.0.1:3020/transactions?chain=testnet&amp;api=http://127.0.0.1:3999">http://127.0.0.1:3020/transactions?chain=testnet&amp;api=http://127.0.0.1:3999</a>.</p>
<p>If you get an error, wait a few minutes and refresh. Once that page loads correctly you should be good to go.</p>
<p>If you are using the Leather wallet, make sure to use the same secret key as used in devnet (deployer wallet). If you are using a different secret key you'll want to run this again and make sure that this is mining to the same wallet you are going to use in your sBTC app. To do that, view the Bitcoin address displayed in Leather (make sure you are on Devnet) and add it to the <code>mine_btc.sh</code> script at the end like this:</p>
<pre><code class="language-bash">btc_address='bcrt1q3tj2fr9scwmcw3rq5m6jslva65f2rqjxfrjz47'
</code></pre>
<p>First, let's mine some BTC with <code>./utils/mine_btc.sh 200</code>. This will mine 200 BTC blocks and ensure our address (Account 1 and Account 2) is funded.</p>
<p>Next we can initiate a deposit, which will deposit a random amount of satoshis from our Bitcoin wallet (Account 2) into the sBTC threshold wallet, minting sBTC in the process.</p>
<p>We can do that with <code>./utils/deposit.sh</code>.</p>
<p>And finally, we can do the reverse, convert our sBTC back to BTC, with <code>./utils/withdraw.sh</code>, which will print the txid of the withdrawal transaction on completion.</p>
<p>Check the results on Stacks at our address:
<a href="http://localhost:3020/address/ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM?chain=testnet&amp;api=http://localhost:3999">http://localhost:3020/address/ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM?chain=testnet&amp;api=http://localhost:3999</a></p>
<p>Check the results on Bitcoin at the txs printed by the utility functions, eg. <a href="http://127.0.0.1:8083/tx/38089273be6ed7521261c3a3a7d1bd36bc67d97123c27263e880350fc519899d">http://127.0.0.1:8083/tx/38089273be6ed7521261c3a3a7d1bd36bc67d97123c27263e880350fc519899d</a>, replacing the txid parameter with the given tx id.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Congratulations! You are among the first people in the world to run sBTC. Now you're ready to actually build something. For that, head over to the <a href="./tutorial.html">End to End Tutorial</a> and we'll build a simple full-stack Bitcoin lending application powered by sBTC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-stacks-sbtc-tutorial"><a class="header" href="#full-stacks-sbtc-tutorial">Full Stacks sBTC Tutorial</a></h1>
<h2 id="build-a-basic-defi-application-using-next-stacksjs-clarity-and-the-sbtc-developer-release"><a class="header" href="#build-a-basic-defi-application-using-next-stacksjs-clarity-and-the-sbtc-developer-release">Build a Basic DeFi Application using Next, Stacks.js, Clarity, and the sBTC Developer Release</a></h2>
<p>If you are looking to start building full-stack applications with the sBTC Developer Release (sBTC DR), this is the place to start. We'll walk through the entire process of building a full-stack application utilizing sBTC from start to finish.</p>
<p>If you prefer a quicker introduction, check out the <a href="./quickstart.html">Quickstart</a>, which will get you up to speed on the essentials of building with sBTC.</p>
<p>First, some housekeeping.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In this tutorial, we'll be building a basic Bitcoin lending app called Lagoon. We'll be using Next for our frontend and the Developer Release of sBTC on Stacks for the smart contract functionality.</p>
<p>We'll be building a full-stack app in this tutorial, primarily working in JavaScript and Clarity.</p>
<p>You should have at least some familiarity with the following before starting:</p>
<ul>
<li>React</li>
<li>Next</li>
<li>Stacks</li>
<li>sBTC</li>
<li>Clarity</li>
</ul>
<p>If you aren't familiar with React or Next for frontend development, I recommend Vercel's <a href="https://nextjs.org/learn/foundations/about-nextjs">Next Foundations</a> to get up to speed.</p>
<p>If you aren't familiar with Stacks, check out <a href="https://docs.stacks.co/docs/stacks-academy">Stacks Academy</a> and if you need an intro to building on Stacks, take a look at the <a href="https://docs.stacks.co/docs/tutorials/hello-stacks">Stacks Developer Quickstart</a>.</p>
<p>To get you up to speed on sBTC, you can start by familiarizing yourself with <a href="./introduction.html">sBTC from a high level</a>.</p>
<p>Specifically, we're working with the <a href="./sbtc-releases/sbtc-dev.html">Developer Release</a> now, which is an early version of sBTC for developers to begin experimenting and building before the full version is released.</p>
<p>Finally, if you aren't familiar with Clarity, you can get the basics, which is enough for this tutorial, by going through this <a href="https://docs.stacks.co/docs/clarity/crash-course">Clarity Crash Course</a>.</p>
<p>You'll also want to make sure you have the <a href="https://leather.io/">Leather web wallet</a> installed, as that is what we'll be using to interact with our application.</p>
<p>Now let's get started.</p>
<h2 id="what-were-building"><a class="header" href="#what-were-building">What We're Building</a></h2>
<p>We're going to be building an app called Lagoon. Lagoon is a very basic Bitcoin lending application that allows you to borrow and lend BTC using Clarity smart contracts. We'll take full advantage of sBTC here and use it in the process.</p>
<p>One of the primary solutions sBTC brings to the world is to create a robust decentralized financial system on top of Bitcoin, rather than needing to go through centralized custodians or pay high fees on the L1.</p>
<p>Lagoon allows users to connect their wallet, convert their BTC to sBTC, and then take that sBTC and deposit it into a lending pool in order to earn interest on it.</p>
<p>This is by no means a production level borrowing and lending app, and is only meant to be used to illustrate how to get started with sBTC. Feel free to use it as a starting point in your projects, but just know that the code is only for demo purposes and should not be used in production.</p>
<h2 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h2>
<p>Note: There are still some bugs being worked out with the testnet sBTC system, so we're going to use a local developer environment for this tutorial.</p>
<p>For this tutorial, we're going to get you set up with a local version of the sBTC DR. Although this does require a bit more setup time, it will pay off by making your development experience significantly faster.</p>
<p>So, before going any further, make sure you have sBTC set up locally by following the <a href="./sbtc-releases/sbtc-dev/get-started-on-devnet.html">Local environment setup guide</a>.</p>
<p>Once you're all set up, it's time to start building!</p>
<p>If at any time you get stuck, you can refer to the final code at the <a href="https://github.com/kenrogers/lagoon">Lagoon repo</a>.</p>
<h2 id="creating-our-front-end"><a class="header" href="#creating-our-front-end">Creating Our Front End</a></h2>
<p>The first thing we need to do is create a new folder for our project, called <code>lagoon</code>.</p>
<pre><code class="language-bash">mkdir lagoon &amp;&amp; cd lagoon
</code></pre>
<p>Inside that we'll initiate our Next project for our frontend.</p>
<pre><code class="language-bash">npx create-next-app@latest
</code></pre>
<p>Use the following values when answering the setup questions:</p>
<ul>
<li>Name: frontend</li>
<li>TypeScript: no</li>
<li>ESLint: up to you</li>
<li>Tailwind: yes</li>
<li>src directory: yes</li>
<li>App Router: yes</li>
<li>Customize import alias: no</li>
</ul>
<p>Now let's get our frontend created. Since this isn't a React/Next tutorial, I'll gloss over the boilerplate code.</p>
<p>First, we need to install the <code>@stacks/connect</code> package as this is what we'll use to connect our wallet.</p>
<pre><code class="language-bash">npm install @stacks/connect
</code></pre>
<p>Now, let's update our <code>layout.js</code> file in <code>frontend/src/app/layout.js</code> to get a Navbar and Connect Wallet component created.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import &quot;./globals.css&quot;;
import { Inter } from &quot;next/font/google&quot;;
import React, { useState, useEffect } from &quot;react&quot;;
import { AppConfig, UserSession } from &quot;@stacks/connect&quot;;

import Navbar from &quot;./components/Navbar&quot;;

const inter = Inter({ subsets: [&quot;latin&quot;] });

export default function RootLayout({ children }) {
  const [userData, setUserData] = useState({});

  const appConfig = new AppConfig();
  const userSession = new UserSession({ appConfig });

  useEffect(() =&gt; {
    if (userSession.isSignInPending()) {
      userSession.handlePendingSignIn().then((userData) =&gt; {
        setUserData(userData);
      });
    } else if (userSession.isUserSignedIn()) {
      setUserData(userSession.loadUserData());
    }
  }, []);
  return (
    &lt;html lang=&quot;en&quot;&gt;
      &lt;body className={inter.className}&gt;
        &lt;div className=&quot;min-h-screen text-white bg-slate-800&quot;&gt;
          {userData !== undefined ? (
            &lt;&gt;
              &lt;Navbar
                userSession={userSession}
                userData={userData}
                setUserData={setUserData}
              /&gt;
              {children}
            &lt;/&gt;
          ) : (
            &quot;&quot;
          )}
        &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>Next up let's add our Navbar by creating a <code>Navbar.js</code> file inside the <code>src/app/components</code> directory.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import Link from &quot;next/link&quot;;
import ConnectWallet from &quot;./ConnectWallet&quot;;

export default function Navbar({ userSession, userData, setUserData }) {
  return (
    &lt;nav className=&quot;flex justify-between p-4 bg-slate-900&quot;&gt;
      &lt;ul className=&quot;flex justify-center space-x-4 text-white&quot;&gt;
        &lt;li&gt;
          &lt;Link href=&quot;/&quot; className=&quot;hover:text-orange-500&quot;&gt;
            Home
          &lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link href=&quot;/lend&quot; className=&quot;hover:text-orange-500&quot;&gt;
            Lend
          &lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link href=&quot;/borrow&quot; className=&quot;hover:text-orange-500&quot;&gt;
            Borrow
          &lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link href=&quot;/deposit&quot; className=&quot;hover:text-orange-500&quot;&gt;
            Deposit BTC
          &lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link href=&quot;/withdraw&quot; className=&quot;hover:text-orange-500&quot;&gt;
            Withdraw sBTC
          &lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      {userData ? (
        &lt;ConnectWallet
          userSession={userSession}
          userData={userData}
          setUserData={setUserData}
        /&gt;
      ) : (
        &quot;&quot;
      )}
    &lt;/nav&gt;
  );
}
</code></pre>
<p>Next we need to create the <code>ConnectWallet.js</code> component. You can do that inside the <code>src/app/components</code> directory.</p>
<p>Inside that file, we'll add the following.</p>
<pre><code class="language-jsx">import { showConnect } from &quot;@stacks/connect&quot;;
import { StacksMocknet, StacksTestnet } from &quot;@stacks/network&quot;;

export default function ConnectWallet({ userSession, userData, setUserData }) {
  const connectWallet = () =&gt; {
    showConnect({
      userSession,
      network: StacksTestnet,
      appDetails: {
        name: &quot;BitLoan&quot;,
        icon: &quot;https://freesvg.org/img/bitcoin.png&quot;,
      },
      onFinish: () =&gt; {
        window.location.reload();
      },
      onCancel: () =&gt; {
        // handle if user closed connection prompt
      },
    });
  };

  const disconnectWallet = () =&gt; {
    userSession.signUserOut(window.location.origin);
    setUserData({});
  };
  return (
    &lt;button
      className=&quot;px-4 py-2 font-bold text-white transition duration-500 ease-in-out rounded bg-gradient-to-r from-purple-500 to-pink-500 hover:from-pink-500 hover:to-orange-500&quot;
      onClick={() =&gt; {
        userData.profile ? disconnectWallet() : connectWallet();
      }}
    &gt;
      {userData.profile ? &quot;Disconnect&quot; : &quot;Connect Wallet&quot;}
    &lt;/button&gt;
  );
}
</code></pre>
<p>All we are doing here is providing a mechanism for the user to connect with a web wallet. Walking through how each piece of the authentication works is outside the scope of this sBTC tutorial. Refer to the Stacks Quickstart linked above if you are unsure of what is happening here.</p>
<p>Then, update your <code>src/app/page.js</code> file to look like this.</p>
<pre><code class="language-jsx">export const metadata = {
  title: &quot;Lagoon&quot;,
  description: &quot;A decentralized Bitcoin lending application&quot;,
};

export default function Home() {
  return (
    &lt;&gt;
      &lt;h1 className=&quot;mt-8 text-4xl text-center&quot;&gt;Lagoon&lt;/h1&gt;
      &lt;p className=&quot;mt-4 text-center&quot;&gt;
        Decentralized lending and borrowing with sBTC.
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Now we're going to add each page and component to create a basic UI.</p>
<p><code>src/app/borrow/page.js</code></p>
<pre><code class="language-jsx">import BorrowForm from &quot;../components/BorrowForm&quot;;

export const metadata = {
  title: &quot;Borrow&quot;,
  description: &quot;A decentralized Bitcoin lending application&quot;,
};

export default function Borrow() {
  return (
    &lt;div className=&quot;min-h-screen text-white bg-gray-800&quot;&gt;
      &lt;h2 className=&quot;my-6 text-3xl text-center&quot;&gt;Borrow sBTC&lt;/h2&gt;
      &lt;BorrowForm /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><code>deposit/page.js</code></p>
<pre><code class="language-jsx">import DepositForm from &quot;../components/DepositForm&quot;;

export const metadata = {
  title: &quot;Deposit&quot;,
  description: &quot;A decentralized Bitcoin lending application&quot;,
};

export default function Deposit() {
  return (
    &lt;div className=&quot;min-h-screen text-white bg-gray-800&quot;&gt;
      &lt;h2 className=&quot;my-6 text-3xl text-center&quot;&gt;Deposit BTC to Mint sBTC&lt;/h2&gt;
      &lt;DepositForm /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><code>lend/page.js</code></p>
<pre><code class="language-jsx">import LendForm from &quot;../components/LendForm&quot;;

export const metadata = {
  title: &quot;Lend&quot;,
  description: &quot;A decentralized Bitcoin lending application&quot;,
};

export default function Lend() {
  return (
    &lt;div className=&quot;min-h-screen text-white bg-gray-800&quot;&gt;
      &lt;h2 className=&quot;my-6 text-3xl text-center&quot;&gt;Lend your sBTC&lt;/h2&gt;
      &lt;LendForm /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><code>withdraw/page.js</code></p>
<pre><code class="language-jsx">import WithdrawForm from &quot;../components/WithdrawForm&quot;;

export const metadata = {
  title: &quot;Withdraw&quot;,
  description: &quot;A decentralized Bitcoin lending application&quot;,
};

export default function Withdraw() {
  return (
    &lt;div className=&quot;min-h-screen text-white bg-gray-800&quot;&gt;
      &lt;h2 className=&quot;my-6 text-3xl text-center&quot;&gt;Withdraw sBTC to BTC&lt;/h2&gt;
      &lt;WithdrawForm /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><code>components/BorrowForm.js</code></p>
<pre><code class="language-jsx">export default function BorrowForm() {
  return (
    &lt;form className=&quot;flex flex-col items-center space-y-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount to borrow&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded  focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Collateral amount&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;w-1/3 px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Borrow sBTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p><code>components/DepositForm.js</code></p>
<pre><code class="language-jsx">export default function DepositForm() {
  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of BTC to deposit&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Deposit BTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p><code>components/LendForm.js</code></p>
<pre><code class="language-jsx">export default function LendForm() {
  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount to lend&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Lend sBTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p><code>components/WithdrawForm.js</code></p>
<pre><code class="language-jsx">export default function WithdrawForm() {
  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of sBTC to withdraw&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Withdraw to BTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>If you run <code>npm run dev</code> from the <code>frontend</code> folder you should see the UI display.</p>
<p>What we have here is a basic UI for converting BTC and sBTC, and borrowing and lending sBTC.</p>
<p>Now that we have our basic UI in place, let's add functionality one piece at a time.</p>
<h2 id="initiating-a-sbtc-deposit"><a class="header" href="#initiating-a-sbtc-deposit">Initiating a sBTC Deposit</a></h2>
<p>The first thing we are going to do is create a component to initiate a sBTC deposit.</p>
<p>You should already be familiar with how sBTC works at a high level, but what we are going to be doing is constructing a custom Bitcoin transaction that will have all the data we need in order to successfully deposit it into the sBTC wallet and then mint our sBTC.</p>
<p>Remember that for the Developer Release, the system that actually does the minting is not the fully decentralized version, it is a centralized single binary, but for the purposes of interacting with it as an application developer, the interface will be very similar to the final version.</p>
<p>Recall that in order to mint sBTC to our Stacks address we need to deposit the amount of BTC we want to convert into the threshold signature wallet, and pass in what Stacks address we want the sBTC minted to in via the OP_RETURN data.</p>
<p>The protocol and sBTC Clarity contracts will handle the actual minting of the sBTC.</p>
<p>We can use the sBTC package to make constructing that transaction much easier, and then we can use Leather's API to broadcast it.</p>
<p>We'll start by installing the sBTC package.</p>
<pre><code class="language-bash">npm install sbtc
</code></pre>
<p>Next we need to set up the context that will allow us to have our <code>UserData</code> available everywhere.</p>
<p>Create the <code>UserContext.js</code> file within the <code>src</code> directory and put this content in it:</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;

export const UserContext = React.createContext();
</code></pre>
<p>This will allow us to read from this file and pull in our authenticated user data in any part of the app.</p>
<p>Let's now update the <code>DepositForm.js</code> component.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import { useState, useContext } from &quot;react&quot;;
import {
  DevEnvHelper,
  sbtcDepositHelper,
  TESTNET,
  TestnetHelper,
  WALLET_00,
  WALLET_01,
} from &quot;sbtc&quot;;
import { bytesToHex, hexToBytes } from &quot;@noble/hashes/utils&quot;;
import * as btc from &quot;@scure/btc-signer&quot;;

import { UserContext } from &quot;../UserContext&quot;;

export default function DepositForm() {
  const { userData } = useContext(UserContext);
  const [satoshis, setSatoshis] = useState(&quot;&quot;);

  const handleInputChange = (event) =&gt; {
    setSatoshis(event.target.value);
  };

  const buildTransaction = async (e) =&gt; {
    e.preventDefault();
    const testnet = new TestnetHelper();
    // const testnet = new DevEnvHelper();

    // setting BTC address for devnet
    // const bitcoinAccountA = await testnet.getBitcoinAccount(WALLET_00);
    // const btcAddress = bitcoinAccountA.wpkh.address;
    // const btcPublicKey = bitcoinAccountA.publicKey.buffer.toString();

    // setting BTC address for testnet
    const btcAddress = userData.profile.btcAddress.p2wpkh.testnet;
    const btcPublicKey = userData.profile.btcPublicKey.p2wpkh;

    let utxos = await testnet.fetchUtxos(btcAddress);

    // If we are working via testnet
    // get sBTC deposit address from bridge API
    const response = await fetch(
      &quot;https://bridge.sbtc.tech/bridge-api/testnet/v1/sbtc/init-ui&quot;
    );
    const data = await response.json();
    const sbtcWalletAddress = data.sbtcContractData.sbtcWalletAddress;

    // if we are working via devnet
    // const sbtcWalletAccount = await testnet.getBitcoinAccount(WALLET_00);
    // const sbtcWalletAddress = sbtcWalletAccount.tr.address;
    const tx = await sbtcDepositHelper({
      // comment this line out if working via devnet
      network: TESTNET,
      sbtcWalletAddress,
      stacksAddress: userData.profile.stxAddress.testnet,
      amountSats: satoshis,
      feeRate: await testnet.estimateFeeRate(&quot;low&quot;),
      utxos,
      bitcoinChangeAddress: btcAddress,
    });

    const psbt = tx.toPSBT();
    const requestParams = {
      publicKey: btcPublicKey,
      hex: bytesToHex(psbt),
    };
    const txResponse = await window.btc.request(&quot;signPsbt&quot;, requestParams);
    const formattedTx = btc.Transaction.fromPSBT(
      hexToBytes(txResponse.result.hex)
    );
    formattedTx.finalize();
    const finalTx = await testnet.broadcastTx(formattedTx);
    console.log(finalTx);
  };

  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of BTC to deposit&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
        value={satoshis}
        onChange={handleInputChange}
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
        onClick={buildTransaction}
      &gt;
        Deposit BTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>Before we go through the code, a reminder that in order to mint sBTC, you initiate a deposit transaction via Bitcoin. So to mint sBTC from a UI like this, we need to construct and broadcast that transaction on the Bitcoin network. Then the sBTC binary will detect that transaction and mint the sBTC.</p>
<p>We need a way to tell the Bitcoin network how much sBTC we want to mint. That's easy, we just send that amount to the threshold wallet. And we need to tell it where to send the sBTC. To do that we need to pass our Stacks address to the OP_RETURN of the Bitcoin transaction.</p>
<p>It can get pretty complicated to construct this manually. Luckily, the sBTC library will do most of the heavy lifting.</p>
<p>Okay let's go through this step by step. First we are importing some packages we need in order to construct our Bitcoin transaction.</p>
<p>We're also using React's state and context APIs to set how many sats we are depositing and to get our <code>userData</code>.</p>
<p>At the bottom you can see in our UI that we have a basic form where users enter how many sats they want to convert and call the <code>buildTransaction</code> function to initiate that.</p>
<p>Let's dig into that function.</p>
<p>The very first thing we are doing is setting what network we are on with either the <code>DevenvHelper</code> or the <code>TestnetHelper</code> from the <code>sbtc</code> package.</p>
<p>Here we have it configured to use either testnet or devnet, depending on which line we have commented out. If you have your local <code>devenv</code> up and running, great, use that. Otherwise, you can use testnet as well, you'll just need to wait for transactions to confirm.</p>
<p>The next thing we need to do is get all of the UTXOs that belong to our currently logged in address. The <code>sbtc</code> package helps us with that as well and we can pass in our authenticated address.</p>
<p>Again, this will be a slightly different process depending on if you are on testnet or devnet.</p>
<p>Bitcoin, unlike the accounts model of something like Ethereum, works off of a UTXO model.</p>
<p>UTXO stands for unspent transaction output, and the collection of UTXOs that are spendable by a specific Bitcoin address determines how much bitcoin an address has.</p>
<p>When we create new transactions, we need to construct the inputs (what is being sent) based on those UTXOs. This helper function gets all of our UTXOs and formats them the right way.</p>
<p>Next we are using the <a href="https://bridge.sbtc.tech">sBTC Bridge</a> API in order to get the current threshold wallet we should be sending the BTC to.</p>
<p>Next it's time to actually build the transaction. To do that we need to pass i:</p>
<ul>
<li>What network we are using, imported from the <code>sbtc</code> package. This defaults to <code>devnet</code> so you only need to pass this parameter if you are using something else.</li>
<li>The threshold wallet address we got above</li>
<li>Our stacks address. This is where the sBTC will be minted to</li>
<li>How many sats we want to deposit and convert to sBTC</li>
<li>The fee to use, we can get this by using another helper from the <code>sbtc</code> package</li>
<li>Our utxos that we fetched</li>
<li>And where to send the remaining Bitcoin change after the transaction (UTXOs can only be spent as a whole, so we need to create another transaction to send any remainder)</li>
</ul>
<p>Then we need to covnert that transaction to a PSBT. In order to use the Leather wallet, our transaction needs to be a PSBT, which we then pass to the wallet, use the wallet to sign, and then use the <code>sbtc</code> helper to broadcast it.</p>
<p>The next few lines are converting the transaction to the right format, calling the wallet API to sign it, and broadcasting it.</p>
<p>Then we simply log the transaction. After you confirm the transaction in the Leather wallet, you can view this transaction in a Bitcoin explorer. Wait a few minutes (or a few seconds on devnet) and you should see your sBTC minted in your wallet.</p>
<p>:::note
If you run into an error about the input script not having a pubKey, make sure you are authenticated with the same account you are initiating the transaction from.
:::</p>
<p>Alright now that we are successfully minting sBTC, we're going to switch gears a bit and build out a super simple Clarity contract to handle our borrowing and lending functionality.</p>
<h2 id="creating-our-lending-smart-contract"><a class="header" href="#creating-our-lending-smart-contract">Creating Our Lending Smart Contract</a></h2>
<p>We're going to be creating our new smart contract inside the sBTC repo we have running.</p>
<p>Switch into <code>sbtc/romeo/asset-contract</code> and run <code>clarinet contract new lagoon</code>.</p>
<p>If you are working from testnet the easiest option will probably be to write and deploy your contract from the <a href="https://explorer.hiro.so/sandbox/deploy?chain=testnet">Hiro explorer sandbox</a>.</p>
<p>We want to developer our smart contract in the same folder and environment as sBTC.</p>
<p>Please keep in mind that this is for demo purposes only. Real DeFi lending systems are much more complex and robust than this. Don't use this as a model for building a DeFi protocol, it's only meant to be a starting point for how to work with sBTC.</p>
<p>Now let's write it.</p>
<p>First we're going to set up the data variables we need.</p>
<pre><code class="language-clojure">;; Define the contract's data variables
(define-map deposits { owner: principal } { amount: uint })
(define-map loans principal { amount: uint, last-interaction-block: uint })

(define-data-var total-deposits uint u0)
(define-data-var total-loans uint u0)
(define-data-var pool-reserve uint u0)
(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate
</code></pre>
<p>We're creating a few different things here. First, we're setting up some maps that define all of the deposits and loans currently in the protocol, assigning an owner and an amount. We also have the <code>last-interaction-block</code> field that will help us calculate how much interest is owed to a lender.</p>
<p>Next up we have a few basic variables defining how many deposits and loans we have in total, the pool reserve, which is the total interest paid by borrowers, and the interest rate, which we are hardcoding here for simplicity.</p>
<p>Now let's write our deposit function. This function will allow users to deposit sBTC into the protocol in order to generate interest.</p>
<pre><code class="language-clojure">(define-public (deposit (amount uint))
    (let (
        (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        )
        (try! (contract-call? .asset transfer amount tx-sender (as-contract tx-sender) none))
        (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })
        (var-set total-deposits (+ (var-get total-deposits) amount))
        (ok true)
    )
)
</code></pre>
<p>Let's walk through this. We are declaring a public function that takes in a <code>uint</code> called <code>amount</code> that will represent how many sats the user wants to deposit into the protocol.</p>
<p>Next we are using <code>let</code> to get the current balance of the depositor. If they have never made a deposit and don't have an entry in the map, we default to 0.</p>
<p>Next up we are initiating a <code>try!</code> call and calling the <code>transfer</code> function from the sBTC contract, <code>.asset</code> in this case. We are transferring the corresponding amount of sBTC from ourselves into the Lagoon contract.</p>
<p>If that is successful, we then update our <code>deposits</code> map to add the amount we just deposited.</p>
<p>Finally, we update the <code>total-deposits</code> as well and return <code>true</code>.</p>
<p>Next up, let's write the <code>borrow</code> function.</p>
<pre><code class="language-clojure">(define-public (borrow (amount uint))
    (let (
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        (allowed-borrow (/ user-deposit u2))
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        (total-due (+ (get amount current-loan-details) (unwrap! accrued-interest (err u8))))
        (new-loan (+ total-due amount))
    )
        (asserts! (&lt;= amount allowed-borrow) (err u7))
        (try! (contract-call? .asset transfer amount (as-contract tx-sender) tx-sender none))
        (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })
        (ok true)
    )
)
</code></pre>
<p>Again here we are using <code>let</code> to retrieve and set the amount this user currently has in the pool, defaulting to 0.</p>
<p>Next we are getting the number that this user is allowed to borrow. Borrowers can only borrow up to 50% of their collateral.</p>
<p>Next we are checking to see how many blocks it has been since they last interacted with the protocol. We set this to keep track of interest accrual. We use the <code>calculate-accrued-interest</code> function (which we'll implement in a moment) to calculate how much they owe and set that as well.</p>
<p>Next we are checking to make sure that the depositor is allowed to borrow and that the pool has enough liquidity to cover the new loan.</p>
<p>Then we transfer the sBTC from the contract to the borrower.</p>
<p>Finally we update all of our variables to include the new amount. Note that when we update these variables, we are taking interest into account. In this case, when this borrower repays this loan, they will repay the original amount plus the 10% interest.</p>
<p>Next up we have the repay function.</p>
<pre><code class="language-clojure">;; Users can repay their sBTC loans
(define-public (repay (amount uint))
    (let (
        (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender)))
        (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))
        (total-due (+ (get amount current-loan-details) (unwrap! accrued-interest (err u8))))
    )
        (asserts! (&gt;= total-due amount) (err u4))
        (try! (contract-call? .asset transfer amount tx-sender (as-contract tx-sender) none))
        (map-set loans tx-sender  { amount: (- total-due amount), last-interaction-block: block-height })
        (var-set total-loans (- (var-get total-loans) amount))
        (ok true)
    )
)
</code></pre>
<p>This is very similar to the other functions. In this case the borrower is simply paying back their loan with the included interest. Remember that the interest was calculated when they initially borrowed, so we don't need to include it here.</p>
<p>Now let's write the function that allows lenders to claim their yield.</p>
<pre><code class="language-clojure">(define-public (claim-yield)
    (let (
        (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))
        (yield-amount (/ (* (var-get pool-reserve) user-deposit) (var-get total-deposits)))
    )
        (try! (as-contract (contract-call? .asset transfer yield-amount (as-contract tx-sender) tx-sender none)))
        (var-set pool-reserve (- (var-get pool-reserve) yield-amount))
        (ok true)
    )
)
</code></pre>
<p>First we get the user's deposits and calculate how much interest they are owed based on their proportion of the pool reserve.</p>
<p>Then we simply transfer that amount to them and update the pool reserve with the new amount.</p>
<p>And finally let's implement the function to calculate interest.</p>
<pre><code class="language-clojure">(define-private (calculate-accrued-interest (principal uint) (start-block uint))
    (let (
        (elapsed-blocks (- block-height start-block))
        (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))
    )
        (asserts! (not (is-eq start-block u0)) (ok u0))
       (ok interest)
    )
)
</code></pre>
<p>Here we are using the amount of elapsed blocks to calculate interest that accrues linearly across blocks. If the user has never taken out a loan, the interest is set to 0.</p>
<p>There is a lot of functionality missing here that we would need in a real DeFi protocol including liquidation, compound interest, withdrawal functionality for depositors, and a lot of controls to ensure the system can't be gamed. The purpose of this tutorial is to show you how to use sBTC, not build a full-fledged DeFi product. As such, we'll keep the functionality basic, as that's enough to understand how to utilize sBTC and the role it would play in a DeFi application.</p>
<p>Before we can interact with our contract, we need to deploy it. To do that, we can create a new deployment plan with Clarinet.</p>
<p>To do this, simply modify the <code>default.devnet.yaml</code> file in deployments and add your new contract to the list of contracts to publish.</p>
<pre><code class="language-yaml">- contract-publish:
    contract-name: lagoon
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    cost: 38610
    path: contracts/lagoon.clar
    anchor-block-only: true
    clarity-version: 2
</code></pre>
<p>Now you'll need to restart your environment and call the <code>deploy_contracts.sh</code> helper again. Refer back to the devnet setup guide if this is confusing.</p>
<p>If you deployed to testnet, you don't need to worry about this part.</p>
<p>Now that we have a basic smart contract in place, let's build the UI to actually interact with it.</p>
<h2 id="creating-the-lend-ui"><a class="header" href="#creating-the-lend-ui">Creating the Lend UI</a></h2>
<p>We're going to be build out the Lend form first. Go ahead and replace the contents of the <code>LendForm.js</code> file with the following, then we'll go through it line by line.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import React, { useState } from &quot;react&quot;;
import { uintCV, PostConditionMode } from &quot;@stacks/transactions&quot;;
import { openContractCall } from &quot;@stacks/connect&quot;;
import { StacksMocknet, StacksTestnet } from &quot;@stacks/network&quot;;

export default function LendForm() {
  const [amount, setAmount] = useState(0);

  const handleDeposit = async () =&gt; {
    const functionArgs = [
      uintCV(amount), // Convert the amount to uintCV
    ];

    const contractAddress = &quot;ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM&quot;; // Replace with your contract address
    const contractName = &quot;lagoon&quot;; // Replace with your contract name
    const functionName = &quot;deposit&quot;; // Function for deposit

    const options = {
      contractAddress,
      contractName,
      functionName,
      functionArgs,
      network: new StacksTestnet(),
      // network: new StacksMocknet(),
      postConditionMode: PostConditionMode.Allow,
      appDetails: {
        name: &quot;Lagoon&quot;,
        icon: &quot;https://freesvg.org/img/bitcoin.png&quot;, // You can provide an icon URL for your application
      },
      onFinish: (data) =&gt; {
        console.log(data);
      },
    };

    await openContractCall(options);
  };

  return (
    &lt;form
      className=&quot;flex items-center justify-center space-x-4&quot;
      onSubmit={(e) =&gt; {
        e.preventDefault();
        handleDeposit();
      }}
    &gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount to lend&quot;
        value={amount}
        onChange={(e) =&gt; setAmount(e.target.value)}
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Lend sBTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<h2 id="creating-the-borrow-ui"><a class="header" href="#creating-the-borrow-ui">Creating the Borrow UI</a></h2>
<p>The borrow UI will be very similar. We're doing almost the exact same thing except renaming a couple things and calling the <code>borrow</code> function instead of <code>lend</code>.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import React, { useState } from &quot;react&quot;;
import { uintCV, PostConditionMode } from &quot;@stacks/transactions&quot;;
import { openContractCall } from &quot;@stacks/connect&quot;;
import { StacksMocknet, StacksTestnet } from &quot;@stacks/network&quot;;

export default function BorrowForm() {
  const [amount, setAmount] = useState(0);

  const handleDeposit = async () =&gt; {
    const functionArgs = [
      uintCV(amount), // Convert the amount to uintCV
    ];

    const contractAddress = &quot;ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM&quot;; // Replace with your contract address
    const contractName = &quot;lagoon&quot;; // Replace with your contract name
    const functionName = &quot;borrow&quot;; // Function for deposit

    const options = {
      contractAddress,
      contractName,
      functionName,
      functionArgs,
      network: new StacksTestnet(),
      //network: new StacksMocknet(),
      postConditionMode: PostConditionMode.Allow,
      appDetails: {
        name: &quot;Lagoon&quot;,
        icon: &quot;https://freesvg.org/img/bitcoin.png&quot;, // You can provide an icon URL for your application
      },
      onFinish: (data) =&gt; {
        console.log(data);
      },
    };

    await openContractCall(options);
  };

  return (
    &lt;form
      className=&quot;flex items-center justify-center space-x-4&quot;
      onSubmit={(e) =&gt; {
        e.preventDefault();
        handleDeposit();
      }}
    &gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount to borrow&quot;
        value={amount}
        onChange={(e) =&gt; setAmount(e.target.value)}
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
      &gt;
        Borrow sBTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<h2 id="initiating-a-sbtc-withdrawal"><a class="header" href="#initiating-a-sbtc-withdrawal">Initiating a sBTC Withdrawal</a></h2>
<p>Now we can mint sBTC, borrow sBTC, and lend out sBTC. Now if we want to convert our sBTC back to BTC, we need to withdraw it. We can do that with a very similar process as the deposit.</p>
<p>Add the following to the <code>WithdrawForm.js</code> file.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import { useState, useContext } from &quot;react&quot;;
import {
  DevEnvHelper,
  sbtcWithdrawHelper,
  sbtcWithdrawMessage,
  TESTNET,
  TestnetHelper,
} from &quot;sbtc&quot;;
import { bytesToHex, hexToBytes } from &quot;@noble/hashes/utils&quot;;
import * as btc from &quot;@scure/btc-signer&quot;;
import { openSignatureRequestPopup } from &quot;@stacks/connect&quot;;

import { UserContext } from &quot;../UserContext&quot;;
import { StacksTestnet } from &quot;@stacks/network&quot;;

export default function WithdrawForm() {
  const { userData, userSession } = useContext(UserContext);
  const [satoshis, setSatoshis] = useState(&quot;&quot;);
  const [signature, setSignature] = useState(&quot;&quot;);

  const handleInputChange = (event) =&gt; {
    setSatoshis(event.target.value);
  };

  const signMessage = async (e) =&gt; {
    e.preventDefault();
    const message =
      sbtcWithdrawMessage({
        network: TESTNET,
        amountSats: satoshis,
        bitcoinAddress: userData.profile.btcAddress.p2wpkh.testnet,
      });

    openSignatureRequestPopup({
      message,
      userSession,
      network: new StacksTestnet(),
      onFinish: (data) =&gt; {
        setSignature(data.signature);
      },
    });
  };

  const buildTransaction = async (e) =&gt; {
    e.preventDefault();
    const testnet = new TestnetHelper();
    // const testnet = new DevEnvHelper();

    let utxos = await testnet.fetchUtxos(
      userData.profile.btcAddress.p2wpkh.testnet
    );

    // get sBTC deposit address from bridge API
    const response = await fetch(
      &quot;https://bridge.sbtc.tech/bridge-api/testnet/v1/sbtc/init-ui&quot;
    );
    const data = await response.json();

    const tx = await sbtcWithdrawHelper({
      network: TESTNET,
      sbtcWalletAddress: data.sbtcContractData.sbtcWalletAddress,
      bitcoinAddress: userData.profile.btcAddress.p2wpkh.testnet,
      amountSats: satoshis,
      signature,
      feeRate: await testnet.estimateFeeRate(&quot;low&quot;),
      fulfillmentFeeSats: 2000,
      utxos,
      bitcoinChangeAddress: userData.profile.btcAddress.p2wpkh.testnet,
    });
    const psbt = tx.toPSBT();
    const requestParams = {
      publicKey: userData.profile.btcPublicKey.p2wpkh.testnet,
      hex: bytesToHex(psbt),
    };
    const txResponse = await window.btc.request(&quot;signPsbt&quot;, requestParams);
    const formattedTx = btc.Transaction.fromPSBT(
      hexToBytes(txResponse.result.hex)
    );
    formattedTx.finalize();
    const finalTx = await testnet.broadcastTx(formattedTx);
    console.log(finalTx);
  };

  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of BTC to deposit&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
        value={satoshis}
        onChange={handleInputChange}
      /&gt;
      &lt;button
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
        onClick={(e) =&gt; {
          signature ? buildTransaction(e) : signMessage(e);
        }}
      &gt;
        {signature ? &quot;Broadcast Withdraw Tx&quot; : &quot;Sign Withdraw Tx&quot;}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>There's a lot going on here, so let's break it down.</p>
<p>First we need to import quite a few different things from <code>sbtc</code> and some stacks.js packages. We'll go over what these do as we use them.</p>
<p>Next we are pulling in our user data and the network we will be working with, testnet in this case.</p>
<p>Next up we have some similar state variables as before, and an addition one, signature.</p>
<p>When we initiate withdrawals, we first need to sign a Stacks message proving we are the owner of the account with the sBTC, then we can take that signature and broadcast it with our withdrawal request on the Bitcoin side.</p>
<p>That's what this <code>signMessage</code> function is doing. We are generating our message in a specific format that the sBTC binary expects it, and then signing it, and saving that signature.</p>
<p>Once that signature is set, we can then broadcast our transaction.</p>
<p>We do that in a similar way to the deposit function, where we use a helper to build the withdrawal transaction, passing it all the data we need (including the signature we just generated) and using Leather to sign and broadcast it.</p>
<p>Once that is broadcasted successfully, you'll see the transaction ID logged and you can view it in a block explorer.</p>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>Congratulations! You just built a basic DeFi app powered by Bitcoin. sBTC is just a baby right now, and many more improvements will be made over the coming months as the system is fully fleshed out.</p>
<p>In the meantime, continue to explore what it's capable of and keep up with development by checking out <a href="https://sbtc.tech">sBTC.tech</a> and <a href="https://bitcoinwrites.com">Bitcoin Writes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiating-a-deposit"><a class="header" href="#initiating-a-deposit">Initiating a Deposit</a></h1>
<p>In order to create a deposit and convert our BTC to sBTC, we need to create and broadcast a Bitcoin transaction with the necessary data.</p>
<p>Below is an example code snippet for doing that using the Leather wallet in a Next.js app.</p>
<p>If you want to see how to do this in the context of a complete full-stack app, check out the <a href="./tutorial.html">tutorial</a>, which this example was pulled from. We have it here for easy reference.</p>
<p>This example heavily relies on the <code>sbtc</code> package. Documentation is in progress, but you can see the <a href="https://github.com/hirosystems/stacks.js/tree/feat/add-sbtc-contracts/packages/sbtc">repo here</a> and take a look at the test files to see examples of how to use it to construct transactions.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import { useState, useContext } from &quot;react&quot;;
import {
  DevEnvHelper,
  sbtcDepositHelper,
  TESTNET,
  TestnetHelper,
  WALLET_00,
  WALLET_01,
} from &quot;sbtc&quot;;
import { bytesToHex, hexToBytes } from &quot;@noble/hashes/utils&quot;;
import * as btc from &quot;@scure/btc-signer&quot;;

import { UserContext } from &quot;../UserContext&quot;;

export default function DepositForm() {
  const { userData } = useContext(UserContext);
  const [satoshis, setSatoshis] = useState(&quot;&quot;);

  const handleInputChange = (event) =&gt; {
    setSatoshis(event.target.value);
  };

  const buildTransaction = async (e) =&gt; {
    e.preventDefault();
    // Helper for working with various API and RPC endpoints and getting and processing data
    // Change this depending on what network you are working with
    const testnet = new TestnetHelper();
    // const testnet = new DevEnvHelper();

    // setting BTC address for devnet
    // Because of some quirks with Leather, we need to pull our BTC wallet using the helper if we are on devnet
    // const bitcoinAccountA = await testnet.getBitcoinAccount(WALLET_00);
    // const btcAddress = bitcoinAccountA.wpkh.address;
    // const btcPublicKey = bitcoinAccountA.publicKey.buffer.toString();

    // setting BTC address for testnet
    // here we are pulling directly from our authenticated wallet
    const btcAddress = userData.profile.btcAddress.p2wpkh.testnet;
    const btcPublicKey = userData.profile.btcPublicKey.p2wpkh;

    let utxos = await testnet.fetchUtxos(btcAddress);

    // If we are working via testnet
    // get sBTC deposit address from bridge API
    const response = await fetch(
      &quot;https://bridge.sbtc.tech/bridge-api/testnet/v1/sbtc/init-ui&quot;
    );
    const data = await response.json();
    const sbtcWalletAddress = data.sbtcContractData.sbtcWalletAddress;

    // if we are working via devnet we can use the helper to get the sbtc wallet address, which is associated with the first wallet
    // const sbtcWalletAccount = await testnet.getBitcoinAccount(WALLET_00);
    // const sbtcWalletAddress = sbtcWalletAccount.tr.address;

    const tx = await sbtcDepositHelper({
      // comment this line out if working via devnet
      network: TESTNET,
      sbtcWalletAddress,
      stacksAddress: userData.profile.stxAddress.testnet,
      amountSats: satoshis,
      // we can use the helper to get an estimated fee for our transaction
      feeRate: await testnet.estimateFeeRate(&quot;low&quot;),
      // the helper will automatically parse through these and use one or some as inputs
      utxos,
      // where we want our remainder to be sent. UTXOs can only be spent as is, not divided, so we need a new input with the difference between our UTXO and how much we want to send
      bitcoinChangeAddress: btcAddress,
    });

    // convert the returned transaction object into a PSBT for Leather to use
    const psbt = tx.toPSBT();
    const requestParams = {
      publicKey: btcPublicKey,
      hex: bytesToHex(psbt),
    };
    // Call Leather API to sign the PSBT and finalize it
    const txResponse = await window.btc.request(&quot;signPsbt&quot;, requestParams);
    const formattedTx = btc.Transaction.fromPSBT(
      hexToBytes(txResponse.result.hex)
    );
    formattedTx.finalize();

    // Broadcast it using the helper
    const finalTx = await testnet.broadcastTx(formattedTx);

    // Get the transaction ID
    console.log(finalTx);
  };

  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of BTC to deposit&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
        value={satoshis}
        onChange={handleInputChange}
      /&gt;
      &lt;button
        type=&quot;submit&quot;
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
        onClick={buildTransaction}
      &gt;
        Deposit BTC
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiating-a-withdrawal"><a class="header" href="#initiating-a-withdrawal">Initiating a Withdrawal</a></h1>
<p>In order to create a withdrawal and convert our sBTC back to BTC, we need to create and broadcast a Bitcoin transaction with the necessary data in addition to signing a Stacks message to prove we own the sBTC we are trying to withdraw.</p>
<p>Below is an example code snippet for doing that using the Leather wallet in a Next.js app.</p>
<p>If you want to see how to do this in the context of a complete full-stack app, check out the <a href="./tutorial.html">tutorial</a>, which this example was pulled from. We have it here for easy reference.</p>
<p>This example heavily relies on the <code>sbtc</code> package. Documentation is in progress, but you can see the <a href="https://github.com/hirosystems/stacks.js/tree/feat/add-sbtc-contracts/packages/sbtc">repo here</a> and take a look at the test files to see examples of how to use it to construct transactions.</p>
<pre><code class="language-jsx">&quot;use client&quot;;

import { useState, useContext } from &quot;react&quot;;
import {
  DevEnvHelper,
  sbtcWithdrawHelper,
  sbtcWithdrawMessage,
  TESTNET,
  TestnetHelper,
} from &quot;sbtc&quot;;
import { bytesToHex, hexToBytes } from &quot;@noble/hashes/utils&quot;;
import * as btc from &quot;@scure/btc-signer&quot;;
import { openSignatureRequestPopup } from &quot;@stacks/connect&quot;;

import { UserContext } from &quot;../UserContext&quot;;
import { StacksTestnet } from &quot;@stacks/network&quot;;

export default function WithdrawForm() {
  const { userData, userSession } = useContext(UserContext);
  const [satoshis, setSatoshis] = useState(&quot;&quot;);
  const [signature, setSignature] = useState(&quot;&quot;);

  const handleInputChange = (event) =&gt; {
    setSatoshis(event.target.value);
  };

  const signMessage = async (e) =&gt; {
    e.preventDefault();

    // First we need to sign a Stacks message to prove we own the sBTC
    // The sbtc paclage can help us format this
    const message =
      sbtcWithdrawMessage({
        network: TESTNET,
        amountSats: satoshis,
        bitcoinAddress: userData.profile.btcAddress.p2wpkh.testnet,
      });

    // Now we can use Leather to sign that message
    openSignatureRequestPopup({
      message,
      userSession,
      network: new StacksTestnet(),
      onFinish: (data) =&gt; {
        // Here we set the signature
        setSignature(data.signature);
      },
    });
  };

  const buildTransaction = async (e) =&gt; {
    // Once the signature has been set, we can build and broadcast the transaction
    e.preventDefault();
    // Helper for working with various API and RPC endpoints and getting and processing data
    // Change this depending on what network you are working with
    const testnet = new TestnetHelper();
    // const testnet = new DevEnvHelper();

    // setting BTC address for devnet
    // Because of some quirks with Leather, we need to pull our BTC wallet using the helper if we are on devnet
    // const bitcoinAccountA = await testnet.getBitcoinAccount(WALLET_00);
    // const btcAddress = bitcoinAccountA.wpkh.address;
    // const btcPublicKey = bitcoinAccountA.publicKey.buffer.toString();

    // setting BTC address for testnet
    // here we are pulling directly from our authenticated wallet
    const btcAddress = userData.profile.btcAddress.p2wpkh.testnet;
    const btcPublicKey = userData.profile.btcPublicKey.p2wpkh;

    let utxos = await testnet.fetchUtxos(btcAddress);

    // If we are working via testnet
    // get sBTC deposit address from bridge API
    const response = await fetch(
      &quot;https://bridge.sbtc.tech/bridge-api/testnet/v1/sbtc/init-ui&quot;
    );
    const data = await response.json();
    const sbtcWalletAddress = data.sbtcContractData.sbtcWalletAddress;

    // if we are working via devnet we can use the helper to get the sbtc wallet address, which is associated with the first wallet
    // const sbtcWalletAccount = await testnet.getBitcoinAccount(WALLET_00);
    // const sbtcWalletAddress = sbtcWalletAccount.tr.address;

    const tx = await sbtcWithdrawHelper({
      // comment this line out if working via devnet
      network: TESTNET,
      sbtcWalletAddress,
      bitcoinAddress: btcAddress,
      amountSats: satoshis,
      signature,
      feeRate: await testnet.estimateFeeRate(&quot;low&quot;),
      fulfillmentFeeSats: 2000,
      utxos,
      bitcoinChangeAddress: btcAddress,
    });
    const psbt = tx.toPSBT();
    const requestParams = {
      publicKey: btcPublicKey,
      hex: bytesToHex(psbt),
    };
    const txResponse = await window.btc.request(&quot;signPsbt&quot;, requestParams);
    const formattedTx = btc.Transaction.fromPSBT(
      hexToBytes(txResponse.result.hex)
    );
    formattedTx.finalize();
    const finalTx = await testnet.broadcastTx(formattedTx);
    console.log(finalTx);
  };

  return (
    &lt;form className=&quot;flex items-center justify-center space-x-4&quot;&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Amount of BTC to deposit&quot;
        className=&quot;w-1/3 px-4 py-2 text-gray-300 bg-gray-700 rounded focus:outline-none focus:border-orange-500&quot;
        value={satoshis}
        onChange={handleInputChange}
      /&gt;
      &lt;button
        className=&quot;px-6 py-2 bg-orange-500 rounded hover:bg-orange-600 focus:outline-none&quot;
        onClick={(e) =&gt; {
          signature ? buildTransaction(e) : signMessage(e);
        }}
      &gt;
        {signature ? &quot;Broadcast Withdraw Tx&quot; : &quot;Sign Withdraw Tx&quot;}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-sbtc-sdk"><a class="header" href="#the-sbtc-sdk">The sBTC SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-operate-a-signer"><a class="header" href="#how-to-operate-a-signer">How to operate a signer</a></h1>
<p>As a Stacker, you are responsible for ensuring the accuracy and integrity of incoming sBTC transactions. To satisfy this requirement and continue to earn BTC rewards, you must operate your own Signer or delegate your signing power to a third-party Signer. See the step-by-step guide to setting up and operating a Signer either by using the <a href="./nakamoto-signer-developer-guide.html">default Signer implementation</a> or by <a href="./nakamoto-signer-developer-guide.html#custom-signer-implementation">utilizing the Signer SDK</a>.</p>
<!-- ## Prerequisites

Rust. To install, please [follow these instructions](https://www.rust-lang.org/tools/install).
Git

## Setting up a Default Signer

### Building from Source

If you wish to compile the default binary from source, follow the steps outlined below. Otherwise, [download the binary directly](#downloading-the-binary).

1. First, clone the Stacks sBTC mono repository:

```console
git clone https://github.com/Trust-Machines/stacks-sbtc.git
```

2. Next, navigate to the stacks-signer-mini directory:

```console
cd stacks-sbtc/stacks-signer-mini
```

3. Checkout the appropriate release branch you wish to use if you are not using the default main branch

```console
git checkout main
```

4. Compile the signer binary:
   Note the binary path defaults to `target/release/stacks-signer-mini`.

```console
cargo build --release
```

### Downloading the Binary

1. First, download the precompiled default [signer binary](LINK).

2. Untar the file

```console
tar -xvf signer_binary.tar
```

3.  Check Extracted Files:
    After running the untar command, the contents of the tar file should be extracted to the current directory. You should see the signer binary (stacks-signer-mini) and the configuration file (signer.toml) listed among the extracted files.

4.  Next, install the signer.

```console
cargo install --path stacks-signer-mini
```

### Configuring and Running the Binary

1. Generate a key pair:
   Create a cryptographic key pair (public key and private key) to uniquely identify yourself as a Signer.
   Safeguard your private key securely to prevent unauthorized access. There are multiple ways to generate a key pair, but consider using the [Stacks CLI](https://docs.hiro.so/get-started/command-line-interface):

```console
# install CLI globally
npm install --global @stacks/cli

# generate a new account and store details in a new file
# '-t' option makes this a testnet account
stx make_keychain -t > cli_keychain.json
```

2. Update the default config:
   Insert your private key into the conf/signer.toml file and update any mandatory options appropriately. Be sure to update any defaults configurations you like for auto signing transactions. For a breakdown of each configuration option, see [Signer Configuration](./how-to-signer-config.md).

3. Run the binary:

```console
stacks-signer-mini --config conf/signer.toml
```

4. Monitor Incoming Transactions:
   The signer binary operates a web server/client and it can be navigated to by default at http://localhost:3000/.
   Here you can see pending transactions and manually review and sign transactions that cannot be automatically signed on your behalf. Note that manual review is triggered based on the options you have set in your configuration file.

## Custom Signer Implementation

If you wish to have more fine-grained control of the Signer binary and its transaction signing logic, you may wish to take advantage of the [Signer SDK](TODO: LINK TO GITHUB REPO).

1. Set Up a New Rust Project

To add a Signer library to your Rust project and create a main function that utilizes it, follow these step-by-step instructions:

If you don't have an existing Rust project, create one using Cargo, Rust's package manager and build tool:

```bash
cargo new my_signer
cd my_signer
```

Replace `my_signer` with your desired project name.

2. Add Signer Library to the `Cargo.toml` File

Open the `Cargo.toml` file in your project directory and add the Signer library as a dependency under the `[dependencies]` section.

```toml
[dependencies]
signer = "1.0.0"
```

Specify the appropriate version that you wish to use. Make sure to check the latest version available on crates.io.

3. Import the Signer Library in Your Rust Code

In your `main.rs` file (located in the `src` folder by default), import the Signer library at the beginning of the file:

```rust
use signer::Signer;
```

4. Create a Main Function

Add the main function to your `main.rs` file. This is where you'll utilize the Signer library to perform the required actions:

```rust
fn main() {
    // Initialize the signer with a private key
    let signer = Signer::new("your_private_key"); // Replace with the actual private key
    // Must serve web client to utilize manual review
    let _ = signer.serve_http("0.0.0.0", 3000);
    while let Ok(transaction) = signer.retrieve_pending_transaction() {
        // Trigger manual review for a specific address
        if transaction.recipient.to_string() == "mr1iPkD9N3RJZZxXRk7xF9d36gffa6exNC" {
            // Manually approve or deny a transaction
            let _ = signer.trigger_manual_review(transaction);
        } else if transaction.amount > 3418260000 {
            // deny transactions with an amount greater than 1 million USD
            let _ = signer.deny(transaction);
        } else {
            // Approve anything else
            let _ = signer.approve(transaction);
        }
    }
}
```

5. Build and Run Your Signer

Now that you've added the Signer library and created the main function, you can build and run your custom signer using Cargo:

```bash
cargo build
cargo run
``` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-release"><a class="header" href="#developer-release">Developer Release</a></h1>
<p><a href="./sbtc-releases/sbtc-dev.html">The sBTC Developer Release</a> is a minimum-viable testnet deployment of sBTC and was decided to be released without the complexity of adding a decentralized set of signers to validate sBTC deposits/withdrawals.</p>
<p>Therefore our beloved Developer Release aka Version 0.1 Alpha Romeo only has one single signer that is operated by a central authority.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-this"><a class="header" href="#what-is-this">What is this</a></h1>
<p>Draft documentation for sBTC Signer specifically for the Nakamoto <a href="https://stacks-network.github.io/sbtc-docs/sbtc-roadmap.html">release</a></p>
<p>The readers of this are assumed to be anyone who is looking to run a sBTC Signer with minimal custom configuration.</p>
<h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<p>Development is ongoing and changes to the Signer configuration should be expected. This document will be updated every sprint to ensure its accuracy.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Rust - <a href="https://www.rust-lang.org/tools/install">To install</a>.</p>
<p>Accessible Stacks node - A Stacks node running the stackerDB instance which is used for signer communication and transaction monitoring and broadcasting.</p>
<p>Accessible Bitcoin node - A Bitcoin node used for transaction monitoring and broadcasting.</p>
<p>A Stacks Private Key - Identify your address as a Signer</p>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<p>If you wish to compile the default binary from source, follow the steps outlined below. Otherwise, download the binary directly (below)</p>
<ol>
<li>First, clone the Stacks sBTC mono repository:</li>
</ol>
<pre><code class="language-console">git clone git@github.com:stacks-network/stacks-blockchain.git
</code></pre>
<ol start="2">
<li>Next, navigate to the stacks-signer directory:</li>
</ol>
<pre><code class="language-console">cd stacks-blockchain/stacks-signer
</code></pre>
<ol start="3">
<li>Checkout the appropriate release branch you wish to use if you are not using the default main branch</li>
</ol>
<pre><code class="language-console">git checkout master
</code></pre>
<ol start="4">
<li>Compile the signer binary:<br />
Note the binary path defaults to <code>target/release/stacks-signer</code>.</li>
</ol>
<pre><code class="language-console">cargo build --release
</code></pre>
<h3 id="downloading-the-binary"><a class="header" href="#downloading-the-binary">Downloading the Binary</a></h3>
<ol>
<li>
<p>First, download the precompiled default <a href="LINK">TODO:NEED:LINK</a>.</p>
</li>
<li>
<p>Untar the file</p>
</li>
</ol>
<pre><code class="language-console">tar -xvf signer_binary.tar
</code></pre>
<ol start="3">
<li>
<p>Check Extracted Files:
After running the untar command, the contents of the tar file should be extracted to the current directory. You should see the signer binary (stacks-signer) and the configuration file (signer.toml) listed among the extracted files.</p>
</li>
<li>
<p>Next, install the signer.</p>
</li>
</ol>
<pre><code class="language-console">cargo install --path stacks-signer
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The signer takes a TOML config file with the following expected properties</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>signer_private_key</code></td><td><code>true</code></td><td>Stacks private key of the signer, used for signing sBTC transactions.</td></tr>
<tr><td><code>stacks_node_rpc_url</code></td><td><code>true</code></td><td>Stacks node RPC URL that points to a node running the stackerDB instance which is used for signer communication and transaction monitoring and broadcasting.</td></tr>
<tr><td><code>bitcoin_node_rpc_url</code></td><td><code>true</code></td><td>Bitcoin node RPC URL used for transaction monitoring and broadcasting.</td></tr>
<tr><td><code>stackerdb_event_endpoint</code></td><td><code>true</code></td><td>RPC endpoint for receiving events from <a href="https://github.com/stacks-network/stacks-blockchain/blob/develop/stackslib/src/net/stackerdb/mod.rs">StackerDB</a></td></tr>
<tr><td><code>stackerdb_contract_id</code></td><td><code>false</code></td><td>StackerDB qualified contract ID for Signer communication. Defaults to &quot;ST11Z60137Y96MF89K1KKRTA3CR6B25WY1Y931668.signers-stackerdb&quot;.</td></tr>
<tr><td><code>network</code></td><td><code>false</code></td><td>One of <code>['Signet', 'Regtest', 'Testnet', 'Bitcoin']</code>. Defaults to <code>Testnet</code></td></tr>
<tr><td><code>signer_api_server_url</code></td><td><code>false</code></td><td>Url at which to host the signer api server for transaction monitoring. Defaults to &quot;http://localhost:3000&quot;.</td></tr>
<tr><td><code>auto_deny_block</code></td><td><code>false</code></td><td>Number of blocks before signing deadline to auto deny a transaction waiting for manual review. Defaults to 10.</td></tr>
<tr><td><code>auto_approve_max_amount</code></td><td><code>false</code></td><td>Maximum amount of a transactions that will be auto approved</td></tr>
<tr><td><code>auto_deny_addresses_btc</code></td><td><code>false</code></td><td>List of bitcoin addresses that trigger an auto deny</td></tr>
<tr><td><code>auto_deny_addresses_stx</code></td><td><code>false</code></td><td>List of stx addresses that trigger an auto deny</td></tr>
<tr><td><code>auto_deny_deadline_blocks</code></td><td><code>false</code></td><td>The number of blocks before deadline at which point the transaction will be auto denied. Default is 10 blocks.</td></tr>
</tbody></table>
</div>
<h3 id="example-toml-file"><a class="header" href="#example-toml-file">Example TOML file</a></h3>
<pre><code class="language-toml"># config.toml

# Mandatory fields

# Note: Replace 'MY_PRIVATE_KEY' with the actual private key value
signer_private_key = &quot;MY_PRIVATE_KEY&quot;
stacks_node_rpc_url = &quot;http://localhost:9776&quot;
bitcoin_node_rpc_url = &quot;http://localhost:9777&quot;
revealer_rpc_url = &quot;http://locahost:9778&quot;

# Optional fields
network = &quot;Signet&quot;
auto_approve_max_amount = 500000
auto_deny_addresses_btc = [
	&quot;BTC_ADDRESS_1&quot;,
	&quot;BTC_ADDRESS_2&quot;
]
auto_deny_addresses_stx = [
	&quot;STX_ADDRESS&quot;
]
auto_deny_deadline_blocks = 120
</code></pre>
<h2 id="running-the-binary"><a class="header" href="#running-the-binary">Running the binary</a></h2>
<p>After installing and creating a config file to run the binary</p>
<pre><code class="language-console">stacks-signer --config conf/signer.toml
</code></pre>
<h2 id="monitor-transactions"><a class="header" href="#monitor-transactions">Monitor Transactions</a></h2>
<p>The signer binary operates a web server/client and it can be navigated to by default at http://localhost:3000/ (unless otherwise specified from config). Here you can see pending transactions and manually review and sign transactions that cannot be automatically signed on your behalf. Note that manual review is triggered based on the options you have set in your configuration file.</p>
<h2 id="custom-signer-implementation"><a class="header" href="#custom-signer-implementation">Custom Signer Implementation</a></h2>
<p>If you wish to have more fine-grained control of the Signer binary and its transaction signing logic, you may wish to take advantage of the [Signer SDK](TODO: LINK TO GITHUB REPO).</p>
<ol>
<li>Set Up a New Rust Project</li>
</ol>
<p>To add a Signer library to your Rust project and create a main function that utilizes it, follow these step-by-step instructions:</p>
<p>If you don't have an existing Rust project, create one using Cargo, Rust's package manager and build tool:</p>
<pre><code class="language-bash">cargo new my_signer
cd my_signer
</code></pre>
<p>Replace <code>my_signer</code> with your desired project name.</p>
<ol start="2">
<li>Add Signer Library to the <code>Cargo.toml</code> File</li>
</ol>
<p>Open the <code>Cargo.toml</code> file in your project directory and add the Signer library as a dependency under the <code>[dependencies]</code> section.</p>
<pre><code class="language-toml">[dependencies]
signer = &quot;1.0.0&quot;
</code></pre>
<p>Specify the appropriate version that you wish to use. Make sure to check the latest version available on crates.io.</p>
<ol start="3">
<li>Import the Signer Library in Your Rust Code</li>
</ol>
<p>In your <code>main.rs</code> file (located in the <code>src</code> folder by default), import the Signer library at the beginning of the file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use signer::Signer;
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>Create a Main Function</li>
</ol>
<p>Add the main function to your <code>main.rs</code> file. This is where you'll utilize the Signer library to perform the required actions:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Initialize the signer with a private key
    let signer = Signer::new(&quot;your_private_key&quot;); // Replace with the actual private key
    // Must serve web client to utilize manual review
    let _ = signer.serve_http(&quot;0.0.0.0&quot;, 3000);
    while let Ok(transaction) = signer.retrieve_pending_transaction() {
        // Trigger manual review for a specific address
        if transaction.recipient.to_string() == &quot;mr1iPkD9N3RJZZxXRk7xF9d36gffa6exNC&quot; {
            // Manually approve or deny a transaction
            let _ = signer.trigger_manual_review(transaction);
        } else if transaction.amount &gt; 3418260000 {
            // deny transactions with an amount greater than 1 million USD
            let _ = signer.deny(transaction);
        } else {
            // Approve anything else
            let _ = signer.approve(transaction);
        }
    }
}</code></pre></pre>
<ol start="5">
<li>Build and Run Your Signer</li>
</ol>
<p>Now that you've added the Signer library and created the main function, you can build and run your custom signer using Cargo:</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>In <a href="./introduction.html">Introduction to sBTC</a> we established that sBTC is a fungible token on the Stacks blockchain, and explained how users interact with the protocol.
This chapter takes a closer look at the major entities in the sBTC protocol and briefly explain how they interact. The following chapters goes into more details on each component.</p>
<p>If you are interested in an in-depth technical explanation of the sBTC system in its entirety, be sure to review the <a href="https://github.com/stacksgov/sips/blob/31dae06bc9c18fa4a7ef43cf7387e83a650228f6/sips/sip-025/sip-025-sbtc.md">proposed SIP</a>.</p>
<p>sBTC builds on the Proof-of-Transfer (PoX) consensus mechanism defined in <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md">SIP-007</a>.
This SIP introduces the concept of stacking, which is to lock STX for a period of time to earn Bitcoin rewards.
Stacking is performed through a special smart contract, called the PoX contract.
People who stack are called stackers.</p>
<p>In sBTC we introduce the following changes to Stacks consensus:</p>
<ul>
<li>The PoX contract is extended to include sBTC as a <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md">SIP-010 fungible token</a>.</li>
<li>Stacks miners must include sBTC mint and burn transactions in their blocks in response to valid sBTC requests on the Bitcoin chain.</li>
<li>Stackers must collectively generate a Bitcoin address every reward cycle and publish it in the PoX contract as the sBTC wallet address.</li>
<li>Stackers are required to respond to sBTC withdrawal requests.</li>
</ul>
<p>The following chart illustrates the main components of sBTC.</p>
<pre class="mermaid">erDiagram
    &quot;PoX Contract&quot; ||--|| &quot;Stacks blockchain&quot; : &quot;Depoloyed on&quot;
    &quot;sBTC Token&quot; }o--|| &quot;PoX Contract&quot;: &quot;Defined in&quot;
    &quot;Stackers&quot; }|--|| &quot;PoX Contract&quot;: &quot;Participate in&quot;
    &quot;sBTC Requests&quot; }o--|| &quot;Stacks blockchain&quot;: &quot;Validated by&quot;
    &quot;Stackers&quot; }|--o{ &quot;sBTC Requests&quot;: &quot;Respond to&quot;
    &quot;User&quot; }o--o{ &quot;sBTC Requests&quot;: &quot;Create&quot;
</pre>
<p>Now that we have established the main components of sBTC, we're ready to dig deeper in the actual workings of it.
The following three chapters explains different aspects of the sBTC design and can be read in any order.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup> PoX is the abbreviation for the Proof-of-Transfer consensus mechanism introduced in <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md">SIP-007</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-requests-and-responses"><a class="header" href="#sbtc-requests-and-responses">sBTC Requests and Responses</a></h1>
<p>Requests to the sBTC system happen on the Bitcoin blockchain. In this chapter, we explain the two requests that users can create. We go over all information they must contain, and how the sBTC protocol responds to the requests.
For a more in-depth reference on how these requests are represented on the Bitcoin blockchain, see <a href="./sbtc-operations/bitcoin-transactions.html">Bitcoin Transactions</a>.</p>
<h2 id="deposit-request"><a class="header" href="#deposit-request">Deposit Request</a></h2>
<p>When a user wishes to deposit BTC in favor of receiving sBTC, they create a deposit request transaction.
This is a bitcoin transaction sending the requested deposit amount of BTC to the address provided by the Stackers.
In addition, the transaction must also specify to which Stacks address the sBTC should be minted.</p>
<p>The sBTC deposit request transaction will therefore contain the following data:</p>
<ul>
<li>Recipient address: The Stacks address which should receive the sBTC.</li>
<li>sBTC wallet address: The Bitcoin address maintaining custody of the deposited BTC.</li>
<li>Amount: The amount to deposit.</li>
</ul>
<h3 id="how-the-protocol-responds-to-a-deposit-request"><a class="header" href="#how-the-protocol-responds-to-a-deposit-request">How the protocol responds to a deposit request</a></h3>
<p>When a deposit request is mined on the Bitcoin blockchain, the next Stacks block must contain an sBTC mint transaction to the recipient address with the designated amount.</p>
<p>This is enforced on a consensus level in Stacks, so that Stacks blocks which do not respond to deposit requests are considered invalid by Miners.</p>
<p>If for some reason the sBTC mint does not materialize, there is a timeout function that will return the user's BTC to them once the subsequent reward cycle finishes.</p>
<h2 id="withdrawal-request"><a class="header" href="#withdrawal-request">Withdrawal Request</a></h2>
<p>An sBTC withdraw request is a bitcoin transaction containing data and two outputs.
The first output of this transaction marks the recipient address of the BTC to be withdrawn.
The second output of this transaction is a small fee subsidy to the stackers intended to cover the transaction cost of fulfilling the withdrawal.
Finally, the transaction specifies the amount to be withdrawn and signs the amount and recipient address with the Stacks address from which the sBTC should be burned.</p>
<p>To summarize, the sBTC withdrawal transaction will contain the following data:</p>
<ul>
<li>Recipient address: The Bitcoin address which should receive the BTC.</li>
<li>sBTC wallet address: The Bitcoin address maintaining custody of the deposited BTC.</li>
<li>Amount: The amount to withdraw.</li>
<li>Sender address: The Stacks address holding the sBTC to be burned.</li>
</ul>
<h3 id="how-the-protocol-responds-to-a-withdrawal-request"><a class="header" href="#how-the-protocol-responds-to-a-withdrawal-request">How the protocol responds to a withdrawal request</a></h3>
<p>When a withdrawal request is mined on the Bitcoin blockchain, the next Stacks block must contain a sBTC burn transaction burning the requested amount from the sender address.
Once the withdrawal request is final<sup class="footnote-reference"><a href="#1">1</a></sup> on the Stacks blockchain, Stackers must fulfill the withdrawal request on the Bitcoin chain by creating a fulfillment transaction.</p>
<p>The fulfillment transaction is a bitcoin transaction sending the requested withdrawal amount to the designated recipient address specified in the Withdrawal request.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Block finality is a property introduced in the <a href="https://stx.is/nakamoto">Nakamoto release</a> of Stacks, and a requirement for sBTC.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitcoin-transactions"><a class="header" href="#bitcoin-transactions">Bitcoin Transactions</a></h1>
<p>This page outlines all transactions which happen on the Bitcoin blockchain within the sBTC protocol, and how they are represented on the bitcoin chain.</p>
<h1 id="data-and-opcodes"><a class="header" href="#data-and-opcodes">Data and opcodes</a></h1>
<p>Common to all sBTC transactions on Bitcoin is that they need to embed data on the Blockchain. To enable this, we require all sBTC transactions to have their first output be a script of the form</p>
<pre><code>OP_RETURN &lt; magic bytes | opcode | data &gt;
</code></pre>
<p>where <code>magic bytes</code> are special bytes required by the Stacks blockchain, the <code>opcode</code> identifies the type of the sBTC transaction, and the <code>data</code> field is specific to the transaction type. We use <code>|</code> as the concatenation operator to denote that all information is pushed as a single byte slice to the bitcoin script.</p>
<p>The magic bytes are</p>
<ul>
<li><code>X2</code> for Stacks mainnet</li>
<li><code>T2</code> for Stacks testnet</li>
</ul>
<p>The opcodes for sBTC are</p>
<ul>
<li><code>&lt;</code>: Deposit request</li>
<li><code>&gt;</code>: Withdrawal request</li>
<li><code>!</code>: Withdrawal fulfillment</li>
<li><code>H</code>: sBTC wallet handoff</li>
</ul>
<p>The following sections will go throuch each of these transactions and outline what data and outputs they require.</p>
<h2 id="deposit-request-1"><a class="header" href="#deposit-request-1">Deposit request</a></h2>
<p>The deposit request contains the following data (incl. opcode and magic byte) in its first output</p>
<pre><code>0       2  3                   66
|-------|--|-------------------|
| magic |op| Recipient address |
</code></pre>
<ul>
<li>Magic: <code>X2</code> or <code>T2</code></li>
<li>Opcode: <code>&lt;</code></li>
<li>Recipient address: Either a standard or a contract principal encoded as a Clarity value as defined in <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#clarity-value-representation">SIP-005</a>.</li>
</ul>
<p>The deposit transaction also has a second output which sends the requested amount to the sBTC wallet address.</p>
<h2 id="withdrawal-request-1"><a class="header" href="#withdrawal-request-1">Withdrawal request</a></h2>
<p>The withdrawal request contains the following data (incl. opcode and magic byte) in its first output</p>
<pre><code>0      2  3          11                76
|------|--|----------|-----------------|
 magic  op   amount       signature
</code></pre>
<ul>
<li>Magic: <code>X2</code> or <code>T2</code></li>
<li>Opcode: <code>&gt;</code></li>
<li>Amount: The amount to withdraw, as an 8-byte big-endian unsigned integer.</li>
<li>Signature: A 65 byte recoverable ECDSA signature authenticating the request.</li>
</ul>
<p>The withdrawal request is required to have two additional outputs beyond the data output. The second output is a dust amount to the recipient address. The third output is a fee subsidy to the sBTC wallet to fund the fulfillment of the withdrawal.</p>
<h3 id="signature"><a class="header" href="#signature">Signature</a></h3>
<p>The recoverable ECDSA signature in the withdrawal request ensures the authenticity and integrity of the transaction. Given that we use the secp256k1 elliptic curve (same as Bitcoin), this signature is composed of 65 bytes.</p>
<h4 id="message-format"><a class="header" href="#message-format">Message Format:</a></h4>
<p>Before diving into the signature's byte-level structure, let's clarify the format of the message being signed.</p>
<p>The signature attests to a withdrawal request from a specific stacks principal. The signed message encapsulates:</p>
<ol>
<li><strong>Amount (8 bytes)</strong>: The total amount to withdraw, encoded as an 8-byte big-endian unsigned integer.</li>
<li><strong>Recipient Address (<code>n</code> bytes)</strong>: This represents the intended beneficiary of the withdrawal. It's encoded as a Bitcoin script. The length of this script, denoted by <code>n</code>, can vary depending on the address format and type.</li>
</ol>
<p>These components are concatenated in the given order, resulting in a byte array with a total length of <code>n+8</code>:</p>
<pre><code>0      8                     n+8
|------|----------------------|
 amount        recipient
</code></pre>
<p>The actual message that gets signed is not this byte array directly but its SHA-256 hash, producing a consistent 32-byte digest.</p>
<h4 id="signature-structure"><a class="header" href="#signature-structure">Signature Structure:</a></h4>
<p>Now, with the hashed message ready, the structure of the recoverable ECDSA signature is as follows:</p>
<pre><code>0   1      33      65
|---|------|-------|
  v    r       s
</code></pre>
<ul>
<li>
<p><strong>v (1 byte)</strong>: The recovery ID, a value between 0 and 3. It's a critical component that facilitates the public key's recovery during verification, eliminating the need for its explicit provision.</p>
</li>
<li>
<p><strong>r (32 bytes)</strong>: A value linked to the x-coordinate of a point on the elliptic curve. It's a pivotal element in ECDSA's verification mechanism, effectively serving as proof of the signer's private key ownership.</p>
</li>
<li>
<p><strong>s (32 bytes)</strong>: This, combined with <code>r</code>, constitutes the essence of the ECDSA signature. Together, they confirm the validity and authenticity of the message.</p>
</li>
</ul>
<p>For the withdrawal request to be deemed valid, the signature must match the expected data.</p>
<h2 id="withdrawal-fulfillment"><a class="header" href="#withdrawal-fulfillment">Withdrawal fulfillment</a></h2>
<p>The withdrawal request contains the following data (incl. opcode and magic byte) in its first output</p>
<pre><code>0      2  3                     35
|------|--|---------------------|
 magic  op       Chain tip
</code></pre>
<ul>
<li>Magic: <code>X2</code> or <code>T2</code></li>
<li>Opcode: <code>!</code></li>
<li>Chain tip: The stacks chain tip used to vaildate the withdrawal.</li>
</ul>
<p>The withdrawal fulfillment has a second output which sends the requested amount to the recipient address.
Finally, the withdrawal fulfillment links back to the withdrawal request transaction by consuming the fee subsidy output of the withdrawal request as its first input.</p>
<h2 id="sbtc-wallet-handoff"><a class="header" href="#sbtc-wallet-handoff">sBTC wallet handoff</a></h2>
<p>The sBTC wallet handoff contains the following data (incl. opcode and magic byte) in its first output</p>
<pre><code>0      2  3                     11
|------|--|---------------------|
 magic  op     Reward cycle
</code></pre>
<ul>
<li>Magic: <code>X2</code> or <code>T2</code></li>
<li>Opcode: <code>H</code></li>
<li>Reward cycle: The reward cycle number of the Stacker set handing over the sBTC wallet.</li>
</ul>
<p>The second output sends an amount greater than or equal to the total amount of sBTC in circulation to the sBTC wallet of the next reward cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commit-reveal-transactions"><a class="header" href="#commit-reveal-transactions">Commit-Reveal Transactions</a></h1>
<p>Thus far, we have have been introduced to some of the Bitcoin transactions that make it possible to interact with sBTC. However, one big drawback of the transaction formats we have been talking about is that they require the creation of custom Bitcoin transactions, which is a moderately sophisticated use case of Bitcoin and thus remains unsupported by some wallets as well as a lot of custodian solutions that are widely used in the current landscape. Cutting out this portion of the Bitcoin ecosystem from being able to use sBTC is not ideal. As a protocol, it is super important that sBTC is accessible to anyone who wants to use it, and this translates to allowing sBTC compatible transactions to be sent from any viable Bitcoin wallet.</p>
<p>To accommodate for this use case, sBTC also supports an alternate transaction wire-format that has universal compatibility with any Bitcoin wallet. Since this scheme uses two transactions to fulfill a sBTC operation, we call it the commit-reveal scheme. As the name suggests, one of the transactions <em>commits</em> the intent of the user and the second transaction <em>reveals</em> it to the protocol.</p>
<p>Note that commit-reveal does not introduce new sBTC operations, but rather an alternate way to <em>express</em> the same operations . From the perspective of the sBTC protocol, these two schemes are completely compatible and interchangeable with each other, in terms of how they are interpreted by the protocol and the effects they produce.</p>
<p>Let's dig a little deeper into the details.</p>
<h2 id="operation-format"><a class="header" href="#operation-format">Operation format</a></h2>
<p>Fundamentally, all sBTC transactions on Bitcoin have to embed some data into the blockchain itself that highlights the intent of the user to interact with the sBTC protocol. The protocol then identifies these intents from the chain and verifies and executes them, thus executing the intent of the user that was previously embedded in the chain.</p>
<p>As long as we have a reliable way to achieve this cycle of embedding an intent into Bitcoin, reading it and processing it, we can fulfill any sBTC operation. Both the direct scheme (SIP-021 style transactions) and transactions that fulfill commit-reveal scheme achieve this, only differing slightly in how the data is embedded into the chain itself.</p>
<p>In the direct scheme, we embed the data directly in the transaction itself, by using an <code>OP_RETURN</code> output.</p>
<p>In the commit reveal scheme, this embedding is done in two stages: the commit transaction and the reveal transaction.</p>
<h3 id="commit-transaction"><a class="header" href="#commit-transaction">Commit transaction</a></h3>
<p>The commit transaction is a very simple transaction with only one requirement: it must contain an output to either a <code>p2tr</code>, <code>p2wsh</code>, <code>p2sh-p2wsh</code> or <code>p2sh</code> address. We need to use these types of addresses because all of them require a user to reveal a script to be spent. We require the revealed script to have the following format:</p>
<pre><code>&lt;DATA&gt; OP_DROP &lt;LOCK SCRIPT...&gt;
</code></pre>
<p>where the <code>DATA</code> part of the script is similar to the corresponding data format of the direct scheme using <code>OP_RETURN</code>, minus the first two magic bytes (that part will be dealt with in the reveal transaction that follows). The data is at most 86 bytes long (the opcode + payload is at most 78 bytes) and also contains an 8 byte chunk that specifies a fee subsidy, i.e. the amount of funds that the reveal transaction is allowed to spend as transaction fees.</p>
<p>The <code>DATA</code> section of the script thus looks like this:</p>
<pre><code>0  1                            n            n + 8
|--|----------------------------|--------------|
 op     sBTC payload               fee subsidy
</code></pre>
<p>where the first byte is the opcode of the sBTC transaction, the payload is essential data required for the specific sBTC operation and the fee subsidy limits the maximum amount of money the reveal transaction is allowed to use as fees.</p>
<h3 id="reveal-transaction"><a class="header" href="#reveal-transaction">Reveal transaction</a></h3>
<p>The reveal transaction is also fairly simple in construction and MUST satisfy the following:</p>
<ol>
<li>It MUST consume an UTXO from a commit transaction as its first input.</li>
<li>The first output MUST be an <code>OP_RETURN</code> output with a three byte payload where the first two bytes are the magic bytes (the same ones we promised to add back) that specify the network they are running on - <code>T2</code> for mainnet and <code>X2</code> for testnet, and the last two bytes is an opcode and a script version byte.
<pre><code>0      2  3         4
|------|--|---------|
 magic  op  version
</code></pre>
</li>
</ol>
<p>The opcode identifies which type of script is revealed. It is <code>w</code> if the script is embedded in segwit witness data, and <code>r</code> if the script is in a p2sh redeem script.</p>
<p>The version identifies the SegWit witness version. It is <code>0</code> for <code>p2wsh</code> scripts and <code>1</code> for <code>p2tr</code> scripts. If the opcode is <code>r</code>, this version byte may be omitted.</p>
<p>Because the reveal transaction consumes the UTXO from the commit transaction, the data that was embedded in the script of the commit transaction is <em>revealed</em>. Thus, when the sBTC protocol observes a bitcoin operation with the opcode <code>w</code> or <code>r</code>, it indicates a reveal transaction and the data for the intended operation by the initiator of the commit transaction can be found in either the witness or redeem script of the first input.</p>
<p>Any remaining outputs of the reveal transaction must be of the same form as in the direct scheme. For instance, the reveal transaction representing an sBTC withdrawal request must contain two additional outputs (just like its direct scheme counterpart) in order: </p>
<ol>
<li>the BTC recipient address </li>
<li>the funding of the fulfillment transaction.</li>
</ol>
<h2 id="processing-the-commit-reveal-scheme-at-the-protocol-level"><a class="header" href="#processing-the-commit-reveal-scheme-at-the-protocol-level">Processing the commit-reveal scheme at the protocol level</a></h2>
<p>Now that we understand how the low level representations of commit-reveal transactions and what they represent, we need to talk about how the sBTC protocol itself interacts with the scheme to ensure fulfillment of such transactions.</p>
<p>On a high level, this diagram summarizes the interactions between the various parties involved in the fulfillment of the commit-reveal scheme:</p>
<pre class="mermaid">sequenceDiagram
  actor User
  User -&gt;&gt; sBTC Committer: 1. Provide sBTC operation data
  sBTC Committer --&gt;&gt; sBTC Revealer: 2. Send witness script and associated data
  sBTC Committer -&gt;&gt; User: 3. Return commit operation address
  User -&gt;&gt; Bitcoin: 4. Broadcast commit transaction
  sBTC Revealer --&gt;&gt; Bitcoin: 5. Read commit transaction
  sBTC Revealer --&gt;&gt; Bitcoin: 6. Broadcast reveal transaction
  Stacks --&gt;&gt; Bitcoin: 7. Process reveal transaction as any sBTC operation
</pre>
<p>More importantly there are three parts of the process that need to interact:</p>
<ol>
<li>The <em>Committer</em> (the person the submitting the <em>commit</em> transaction, initiating the scheme)</li>
<li>The <em>Revealer</em> (the person that consumes <em>commit</em> transactions and initiates reveal transactions)</li>
<li>The Bitcoin blockchain itself, which provides the underlying data layer which is used to express the scheme</li>
</ol>
<p>The <em>Committer</em> can be thought of as a system that interacts with a user wallet and constructs <em>commit</em> transactions (like the sBTC bridge).</p>
<p>The <em>Revealer</em> can be thought of a specific system that participates in the sBTC protocol, maintaining a wallet and can consume <em>commit</em> transactions and broadcast <em>reveal</em> transactions. They probably have convenient API endpoints for the <em>Committer</em> to use to construct Witness data.</p>
<p>Here is an example flow of data through the protocol (for illustration purposes only):</p>
<ol>
<li>User interacts with a web UI of a <em>Committer</em>, providing operation data to construct the commit transaction</li>
<li>The <em>Committer</em> constructs a witness script that can be spent by the <em>Revealer</em></li>
<li>The <em>Committer</em> then sends this witness script and any other associated data that might be required to construct a reveal transaction to the <em>Revealer</em></li>
<li>The <em>Committer</em> returns the address to send the <em>commit</em> operation to the user</li>
<li>User broadcasts the <em>commit</em> transaction by making a payment to the given commit address</li>
<li>The <em>Revealer</em> reads the <em>commit</em> transaction, having already processed the witness script</li>
<li>The <em>Revealer</em> broadcasts the <em>reveal</em> transaction (there can be economic incentives here that makes the <em>Revealer</em> not reveal a <em>commit</em> transaction. For example, if the cost of revealing the transaction is too high, the <em>Revealer</em> might choose to ignore it altogether)</li>
<li>The sBTC protocol picks up the <em>reveal</em> transaction and fulfills it (by interpreting the operation data from the witness script)</li>
</ol>
<p>NOTE: <em>It is entirely possible for the <em>Revealer</em> to steal the witness data and use it for its own benefit, although this will be entire visible on the Bitcoin chain data itself and can be completely traced. Thus, there needs to be some degree of cryptoeconomic incentives present that discourage the <em>Revealer</em> from doing this.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-clarity-contracts"><a class="header" href="#sbtc-clarity-contracts">sBTC Clarity Contracts</a></h1>
<p>One of the key pieces of the sBTC system is the set of Clarity contracts that facilitate the operations of the sBTC token.</p>
<p>Recall that sBTC is a <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md">SIP-010 fungible token</a> on the Stacks chain. This provides an easy-to-use interface for interacting with sBTC.</p>
<p>Upon successful deposit and withdrawal transactions the signer system will call functions in this contract. Here we'll walk through the contracts and explain what each piece is doing so you have a thorough understanding of the Clarity code running sBTC.</p>
<p>:::note
It's important to note that sBTC is currently in <a href="./sbtc-releases/sbtc-dev.html">Developer Release</a>. This is a developer preview so developers can begin learning and experimenting with sBTC before moving to the fully decentralized version. As such, these contracts are subject to change.
:::</p>
<p>The Clarity contracts live in the <a href="https://github.com/stacks-network/sbtc/tree/main/romeo/asset-contract/contracts"><code>romeo/asset-contract/contracts</code></a> folder of the <a href="https://github.com/stacks-network/sbtc"><code>sbtc</code> repo</a>.</p>
<p>In that folder you'll see three files:</p>
<ul>
<li><code>asset.clar</code></li>
<li><code>clarity-bitcoin-mini-deploy.clar</code></li>
<li><code>clarity-bitcoin-mini.clar</code></li>
</ul>
<p>The <code>asset</code> contract is what does the heavy lifting for sBTC operations. The <code>clarity-bitcoin-mini</code> library is a stateless utility library to make it easier to interact with Bitcoin. This is a key feature of sBTC and this library provides several helper functions to handle that.</p>
<p>The <code>clarity-bitcoin-mini-deploy</code> contract is exactly the same, except debug mode is set to false for production.</p>
<p>Now, let's go through the <code>asset</code> contract.</p>
<pre><code class="language-clojure">;; title: wrapped BTC on Stacks
;; version: 0.1.0
;; summary: sBTC dev release asset contract
;; description: sBTC is a wrapped BTC asset on Stacks.
;; It is a fungible token (SIP-10) that is backed 1:1 by BTC
;; For this version the wallet is controlled by a centralized entity.
;; sBTC is minted when BTC is deposited into the wallet and
;; burned when BTC is withdrawn from the wallet.
;; Requests for minting and burning are made by the contract owner.

;; token definitions
;; 100 M sats = 1 sBTC
;; 21 M sBTC supply = 2.1 Q sats total
(define-fungible-token sbtc u2100000000000000)

;; constants
;;
(define-constant err-invalid-caller (err u4))
(define-constant err-forbidden (err u403))
(define-constant err-btc-tx-already-used (err u500))

;; data vars
;;
(define-data-var contract-owner principal tx-sender)
(define-data-var bitcoin-wallet-public-key (optional (buff 33)) none)

;; stores all btc txids that have been used to mint or burn sBTC
(define-map amounts-by-btc-tx (buff 32) int)

;; public functions
;;

;; #[allow(unchecked_data)]
(define-public (set-contract-owner (new-owner principal))
  (begin
    (try! (is-contract-owner))
    (ok (var-set contract-owner new-owner))
  )
)

;; #[allow(unchecked_data)]
(define-public (set-bitcoin-wallet-public-key (public-key (buff 33)))
    (begin
        (try! (is-contract-owner))
        (ok (var-set bitcoin-wallet-public-key (some public-key)))
    )
)

;; #[allow(unchecked_data)]
(define-public (mint (amount uint)
    (destination principal)
    (deposit-txid (buff 32))
    (burn-chain-height uint)
    (merkle-proof (list 14 (buff 32)))
    (tx-index uint)
    (block-header (buff 80)))
    (begin
        (try! (is-contract-owner))
        (try! (verify-txid-exists-on-burn-chain deposit-txid burn-chain-height merkle-proof tx-index block-header))
        (asserts! (map-insert amounts-by-btc-tx deposit-txid (to-int amount)) err-btc-tx-already-used)
        (try! (ft-mint? sbtc amount destination))
        (print {notification: &quot;mint&quot;, payload: deposit-txid})
        (ok true)
    )
)

;; #[allow(unchecked_data)]
(define-public (burn (amount uint)
    (owner principal)
    (withdraw-txid (buff 32))
    (burn-chain-height uint)
    (merkle-proof (list 14 (buff 32)))
    (tx-index uint)
    (block-header (buff 80)))
    (begin
        (try! (is-contract-owner))
        (try! (verify-txid-exists-on-burn-chain withdraw-txid burn-chain-height merkle-proof tx-index block-header))
        (asserts! (map-insert amounts-by-btc-tx withdraw-txid (* -1 (to-int amount))) err-btc-tx-already-used)
        (try! (ft-burn? sbtc amount owner))
        (print {notification: &quot;burn&quot;, payload: withdraw-txid})
    	(ok true)
    )
)

;; #[allow(unchecked_data)]
(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
	(begin
        (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) err-invalid-caller)
		(try! (ft-transfer? sbtc amount sender recipient))
		(match memo to-print (print to-print) 0x)
		(ok true)
	)
)

;; read only functions
;;
(define-read-only (get-bitcoin-wallet-public-key)
    (var-get bitcoin-wallet-public-key)
)

(define-read-only (get-contract-owner)
    (var-get contract-owner)
)

(define-read-only (get-name)
	(ok &quot;sBTC&quot;)
)

(define-read-only (get-symbol)
	(ok &quot;sBTC&quot;)
)

(define-read-only (get-decimals)
	(ok u8)
)

(define-read-only (get-balance (who principal))
	(ok (ft-get-balance sbtc who))
)

(define-read-only (get-total-supply)
	(ok (ft-get-supply sbtc))
)

(define-read-only (get-token-uri)
	(ok (some u&quot;https://gateway.pinata.cloud/ipfs/Qma5P7LFGQAXt7gzkNZGxet5qJcVxgeXsenDXwu9y45hpr?_gl=1*1mxodt*_ga*OTU1OTQzMjE2LjE2OTQwMzk2MjM.*_ga_5RMPXG14TE*MTY5NDA4MzA3OC40LjEuMTY5NDA4MzQzOC42MC4wLjA&quot;))
)

(define-read-only (get-amount-by-btc-txid (btc-txid (buff 32)))
    (map-get? amounts-by-btc-tx btc-txid)
)

;; private functions
;;
(define-private (is-contract-owner)
    (ok (asserts! (is-eq (var-get contract-owner) contract-caller) err-forbidden))
)

(define-read-only (verify-txid-exists-on-burn-chain (txid (buff 32)) (burn-chain-height uint) (merkle-proof (list 14 (buff 32))) (tx-index uint) (block-header (buff 80)))
    (contract-call? .clarity-bitcoin-mini was-txid-mined burn-chain-height txid block-header { tx-index: tx-index, hashes: merkle-proof})
)
</code></pre>
<p>Although powerful, the sBTC contract is actually relatively simple. The <code>mint</code> and <code>burn</code> functions of the contract will not be interacted with directly by a developer or a user, but instead will be called by the sBTC signer system upon successful deposit and withdrawal requests. The <code>transfer</code> function, however, will often be called by developers for users looking to transfer their sBTC.</p>
<p>Up at the top we are setting some variables, most notably the sBTC supply, which is set to match 1:1 with BTC supply.</p>
<p>We also have the contract owner and Bitcoin wallet public key which will be set by the sBTC protocol. As per the design documentation, the Bitcoin public key will change every stacking reward cycle to the new threshold wallet.</p>
<p>Next we have two basic public functions to set those two variables.</p>
<p>Finally we are defining a map to define all deposit and withdrawal transaction IDs to ensure that once a particular Bitcoin transaction has been used in a sBTC operation, it can not be used again.</p>
<p>The next three functions comprise the bulk of the sBTC functionality.</p>
<p>Before we get to those, let's take a look at the <code>verify-txid-exists-on-burn-chain</code> towards the bottom of the contract. This utilizes the helper contract to ensure that a transaction actually happened on the Bitcoin chain.</p>
<p>This native integration with the Bitcoin L1 is one of the great parts of Clarity, as we can verify directly from our smart contracts whether or not a Bitcoin transaction was actually mined, all on chain.</p>
<pre><code class="language-clojure">(define-read-only (verify-txid-exists-on-burn-chain (txid (buff 32)) (burn-chain-height uint) (merkle-proof (list 14 (buff 32))) (tx-index uint) (block-header (buff 80)))
    (contract-call? .clarity-bitcoin-mini was-txid-mined burn-chain-height txid block-header { tx-index: tx-index, hashes: merkle-proof})
)
</code></pre>
<p>This takes in a transaction ID, the Bitcoin block height the transaction was in, and a merkle proof. All of this information is passed to the library to verify that the transaction actually occurred.</p>
<p>For some more context on how this process works and to see how to use it your own projects, be sure to check out the <a href="https://bitcoinprimer.dev">Bitcoin Primer</a>.</p>
<h2 id="mint"><a class="header" href="#mint">Mint</a></h2>
<pre><code class="language-clojure">;; #[allow(unchecked_data)]
(define-public (mint (amount uint)
    (destination principal)
    (deposit-txid (buff 32))
    (burn-chain-height uint)
    (merkle-proof (list 14 (buff 32)))
    (tx-index uint)
    (block-header (buff 80)))
    (begin
        (try! (is-contract-owner))
        (try! (verify-txid-exists-on-burn-chain deposit-txid burn-chain-height merkle-proof tx-index block-header))
        (asserts! (map-insert amounts-by-btc-tx deposit-txid (to-int amount)) err-btc-tx-already-used)
        (try! (ft-mint? sbtc amount destination))
        (print {notification: &quot;mint&quot;, payload: deposit-txid})
        (ok true)
    )
)
</code></pre>
<p>Now we get to the <code>mint</code> function. This is the function that is called when a deposit transaction is initiated and processed on the Bitcoin side. The signer will detect that and call the <code>mint</code> function.</p>
<p>This function takes in some information that is all read directly from the provided Bitcoin transaction. It includes the Stacks principal to mint the sBTC to, and all of the required Bitcoin transaction information required to verify it.</p>
<p>It then checks to make sure the contract owner (the signer system) is calling it, makes sure the Bitcoin transaction actually happened, updates the map of Bitcoin transactions that have been used in sBTC operations, and mints the token to the specified Stacks principal.</p>
<h2 id="burn"><a class="header" href="#burn">Burn</a></h2>
<pre><code class="language-clojure">;; #[allow(unchecked_data)]
(define-public (burn (amount uint)
    (owner principal)
    (withdraw-txid (buff 32))
    (burn-chain-height uint)
    (merkle-proof (list 14 (buff 32)))
    (tx-index uint)
    (block-header (buff 80)))
    (begin
        (try! (is-contract-owner))
        (try! (verify-txid-exists-on-burn-chain withdraw-txid burn-chain-height merkle-proof tx-index block-header))
        (asserts! (map-insert amounts-by-btc-tx withdraw-txid (* -1 (to-int amount))) err-btc-tx-already-used)
        (try! (ft-burn? sbtc amount owner))
        (print {notification: &quot;burn&quot;, payload: withdraw-txid})
    	(ok true)
    )
)
</code></pre>
<p>The <code>burn</code> function works much the same except it is called upon a successful withdrawal request, when a user wants to convert their sBTC back to BTC.</p>
<h2 id="transfer"><a class="header" href="#transfer">Transfer</a></h2>
<pre><code class="language-clojure">;; #[allow(unchecked_data)]
(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))
	(begin
        (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) err-invalid-caller)
		(try! (ft-transfer? sbtc amount sender recipient))
		(match memo to-print (print to-print) 0x)
		(ok true)
	)
)
</code></pre>
<p>Finally we have a basic transfer function that allows users to transfer sBTC between each other.</p>
<p>The rest of the functions are basic <code>read-only</code> functions that are used to retrieve information about the asset.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacker-responsibilities"><a class="header" href="#stacker-responsibilities">Stacker responsibilities</a></h1>
<p>One of the most significant changes to accommodate the sBTC design is that Stackers must now perform active work to continue receiving PoX rewards. Stackers provide partial signatures for BTC withdrawal fulfillment transactions[the BTC wallet] for the duration of each reward cycle in which their STX are locked. This chapter outlines the new role of the stackers, and how they interact with each other to fulfill their duties.</p>
<h2 id="sbtc-wallet-address-generation"><a class="header" href="#sbtc-wallet-address-generation">sBTC wallet address generation</a></h2>
<p>Stackers in sBTC operate in Reward cycles similar to previous versions of <a href="https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md">PoX</a>. However, the reward cycle has been modified to consist of three phases: prepare (80 blocks), handoff (20 blocks), and reward (2000 blocks).</p>
<p>During the prepare phase, miners decide on an anchor block and the next reward cycle's Stackers as before. During the handoff phase, this new set of Stackers MUST collectively determine and provide a single Bitcoin address in the PoX contract to operate as the sBTC wallet address for the next reward cycle. If they fail to do so within the first 10 blocks of the handoff phase, the prepare phase is reinitiated and a new set of stackers will be selected.</p>
<p>If no valid sBTC address is provided, the current set of Stackers' continue operating as before. Their STX will remain frozen, and they will continue to receive PoX rewards until a successful prepare phase and handoff has occurred. However, once the new set of stackers has provided an sBTC wallet address, the current set of Stackers MUST execute a wallet handoff to this newly generated sBTC wallet address.</p>
<h2 id="sbtc-wallet-handoff-1"><a class="header" href="#sbtc-wallet-handoff-1">sBTC Wallet handoff</a></h2>
<p>An sBTC Wallet handoff is used by the current reward cycle's Stackers to send all deposited BTC to the next reward cycle's Stackers' sBTC wallet address within 10 blocks of the reward cycle starting. Additionally, Stackers MUST transfer an <em>equal or greater</em> number of BTC than the amount of sBTC that existed at the end of their own wallet's lifetime. This implies that Stackers MUST cover any fee costs associated with fulfilling sBTC withdrawal requests.</p>
<h2 id="sbtc-withdrawal-fulfillment"><a class="header" href="#sbtc-withdrawal-fulfillment">sBTC Withdrawal fulfillment</a></h2>
<p>To fulfill an sBTC withdrawal request, Stackers send one or more Bitcoin transactions that pay the requested amount of BTC to the withdrawal address stipulated by the withdrawal request. If Stackers have received their sBTC wallet handoff and they fail to fulfill a request within 50 Bitcoin blocks of the request being finalized (i.e. at most 150 Bitcoin blocks after the request is submitted), then the system transitions to Recovery mode and PoX payouts are repurposed for fulfilling pending withdrawal requests.</p>
<p>If Stackers do not fulfill the pending sBTC withdrawal requests, their STX will be frozen by .pox and any earned BTC used to fulfill these pending requests. Stackers may only receive back their STX and resume earning BTC once all the withdrawal requests for which they were responsible are fulfilled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature-aggregation-with-frost"><a class="header" href="#signature-aggregation-with-frost">Signature Aggregation with FROST</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsts-adaptation"><a class="header" href="#wsts-adaptation">WSTS Adaptation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing-protocol"><a class="header" href="#signing-protocol">Signing protocol</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stackerdb"><a class="header" href="#stackerdb">StackerDB</a></h1>
<p>Covers the StackerDB system and how it works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-releases"><a class="header" href="#sbtc-releases">sBTC Releases</a></h1>
<p>Since sBTC is a complex system, we have defined multiple releases of the system to incrementally add functionality and grow the complexity of the system.
These are the planned releases:</p>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Name (optional)</th><th>Released</th></tr></thead><tbody>
<tr><td>0.1</td><td>sBTC Developer</td><td></td></tr>
<tr><td>1.0</td><td>sBTC Nakamoto</td><td></td></tr>
<tr><td>1.1</td><td>sBTC Nakamoto v2</td><td></td></tr>
</tbody></table>
</div>
<p>The following table highlights the main differences between the releases</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>0.1</th><th>1.0</th><th>1.1</th></tr></thead><tbody>
<tr><td>sBTC token</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>OP_RETURN data</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Commit-Reveal data</td><td></td><td>✅</td><td>✅</td></tr>
<tr><td>Mainnet</td><td></td><td>✅</td><td>✅</td></tr>
<tr><td>Open Membership</td><td></td><td>✅</td><td>✅</td></tr>
<tr><td>Consensus breaking</td><td></td><td>✅</td><td>✅</td></tr>
<tr><td>Liveness ratio</td><td></td><td></td><td>✅</td></tr>
<tr><td>Recovery mode</td><td></td><td></td><td>✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-developer-release-01"><a class="header" href="#sbtc-developer-release-01">sBTC Developer Release (0.1)</a></h1>
<p>The sBTC Developer Release (sBTC DR) facilitates the complete deposit and withdrawal processes of sBTC, simulating the core mechanics of the sBTC system in the form of a singular service.</p>
<p>This release includes an asset contract alongside a dedicated binary. Primarily designed for use on testnet or local development networks. While it's technically possible for anyone to deploy the sBTC DR on the mainnet, it's not recommended due to its developmental nature.</p>
<p>Upon activation, the sBTC DR binary takes charge: it deploys the asset contract and actively monitors sBTC operations. When a deposit request comes in, the system mints the corresponding sBTC tokens to the specified address. Similarly, upon a withdrawal request, it burns the requisite sBTC tokens and promptly processes the withdrawal, transferring the designated BTC amount to the intended recipient.</p>
<pre class="mermaid">graph TD;
  A[User] --&gt; B[Deposit Request];
  A --&gt; C[Withdrawal Request];
  D[sBTC DR Binary] --&gt; F[Listen to sBTC Operations];
  B --&gt; G[Mint sBTC Tokens];
  C --&gt; H[Burn sBTC Tokens];
  H --&gt; J[Send BTC to Recipient];

  classDef userStyle fill:#f9d457,stroke:#f28482;
  classDef operationStyle fill:#bee3db,stroke:#2a9d8f;
  classDef processStyle fill:#f4a261,stroke:#e76f51;
  class A userStyle;
  class B,C operationStyle;
  class D,F,G,H,I,J processStyle;
  class E operationStyle;
</pre>
<h2 id="sbtc-developer-release-reference-implementation-plan"><a class="header" href="#sbtc-developer-release-reference-implementation-plan">sBTC Developer release reference implementation plan</a></h2>
<p>The reference implementation of the sBTC developer release, codenamed Alpha Romeo, is currently under implementation in <a href="https://github.com/stacks-network/sbtc/tree/master/romeo">this repository</a>.
Every piece of functionality that is being worked on is formulated as <a href="https://github.com/stacks-network/sbtc/issues">issues</a> with the [sBTC DR] prefix and <code>alpha-romeo</code> label.</p>
<p>For anyone interested in tracking the high-level progress of the Alpha Romeo work, these key issues should provide a good view in how things are progressing.</p>
<ol>
<li>Implement the deposit flow <a href="https://github.com/stacks-network/sbtc/issues/67">#67</a></li>
<li>Implement the withdrawal flow <a href="https://github.com/stacks-network/sbtc/issues/68">#68</a></li>
<li>Containerize and deploy the release <a href="https://github.com/stacks-network/sbtc/issues/85">#85</a></li>
<li>Ensure the bridge is compatible with the latest release <a href="https://github.com/stacks-network/sbtc/issues/86">#86</a></li>
<li>Write developer docs for the release <a href="https://github.com/stacks-network/sbtc-docs/issues/77">#77</a></li>
</ol>
<p>The sBTC contract has be deployed on the Stacks testnet at <a href="https://explorer.hiro.so/txid/ST3VA3Y7A2YQ8GW69T0N1ERPAD784R1Y2YHCSNJHH.asset?chain=testnet">ST3VA3Y7A2YQ8GW69T0N1ERPAD784R1Y2YHCSNJHH.asset</a>.</p>
<p>In sBTC 0.1, the deposit and withdrawal transactions are processed by a central authority (CA). The flow is as follows:</p>
<pre class="mermaid">sequenceDiagram
    actor AB as Alice-BTC
    participant CB as CA-BTC
    participant CS as CA-STX
    actor AS as Alice-STX
    CS -&gt;&gt; CS: deploys contract
    Note over AB, AS: BTC tx before contract deployment are ignored.
    loop
        AB -&gt;&gt; CB: sends BTC (deposit)
        CB -&gt;&gt; CS: processes BTC tx
        CS -&gt;&gt; AS: mints sBTC
    end
    loop
        AB -&gt;&gt; CB: sends dust (withdrawal)
        CB -&gt;&gt; CS: processes BTC tx
        CS -&gt;&gt; AS: burns sBTC
        CB -&gt;&gt; AB: sends BTC (fullfilment)
    end
</pre>
<h2 id="web-app"><a class="header" href="#web-app">Web app</a></h2>
<h3 id="bridge-on-testnet"><a class="header" href="#bridge-on-testnet">Bridge on Testnet</a></h3>
<p>A web interface for the sBTC contract on Stacks testnet is available at <a href="https://bridge.sbtc.tech/?net=testnet">https://bridge.sbtc.tech/?net=testnet</a></p>
<p>The web app allows to deposit and withdraw btc from the sbtc wallet. It also provides a list of recent deposit and withdrawal transactions.</p>
<h3 id="demo-application"><a class="header" href="#demo-application">Demo application</a></h3>
<p>An open source application written with next.js is availble at <a href="https://github.com/kenrogers/lagoon">https://github.com/kenrogers/lagoon</a>. This application allows to lend sBTC as well as to deposit and withdraw btc. It is used in the <a href="sbtc-releases//tutorial.html">end to end tutorial</a>.</p>
<h3 id="wallet-support"><a class="header" href="#wallet-support">Wallet support</a></h3>
<p>These applications use sbtc SDK library that works with <a href="https://github.com/leather-wallet/extension/releases">Leather wallet version 6.11+</a>.</p>
<h2 id="sbtc-cli"><a class="header" href="#sbtc-cli">sBTC cli</a></h2>
<p>See <a href="https://github.com/stacks-network/sbtc/blob/main/sbtc-cli/README.md">README of the sbtc repo</a> for commands to create and broadcast deposit and withdrawal bitcoin transactions.</p>
<h2 id="sbtc-api"><a class="header" href="#sbtc-api">sBTC API</a></h2>
<p>There is a public API server for the most common tasks in the context of sBTC. Developers can use this API create deposit and withdrawal request, get information about btc transactions, etc.</p>
<p>Documention is available at <a href="https://bridge.sbtc.tech/bridge-api/docs/">bridge.sbtc.tech</a>.</p>
<h2 id="sbtc-sdk"><a class="header" href="#sbtc-sdk">sBTC SDK</a></h2>
<p>stacks.js has added support for sBTC deposit and withdrawal requests. Current work in progress can be seen at <a href="https://github.com/hirosystems/stacks.js/pull/1554">stacks.js/feat/add-sbtc-contracts</a>.</p>
<p>The package is published on <a href="https://www.npmjs.com/package/sbtc">npmjs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="devenv"><a class="header" href="#devenv">Devenv</a></h2>
<h3 id="what-is-the-meaning-of-the-warning-in-stacks-logs-relayer-failed-to-submit-bitcoin-transaction"><a class="header" href="#what-is-the-meaning-of-the-warning-in-stacks-logs-relayer-failed-to-submit-bitcoin-transaction">What is the meaning of the warning in stacks logs <code>Relayer: Failed to submit Bitcoin transaction</code>?</a></h3>
<p>It is a warning related to stacks mining and not relevant to sBTC transactions.</p>
<h3 id="how-to-check-progress-when-starting-devenv-when-can-i-start-sending-deposits"><a class="header" href="#how-to-check-progress-when-starting-devenv-when-can-i-start-sending-deposits">How to check progress when starting devenv? When can I start sending deposits?</a></h3>
<p>Wait until the stacks block height (<code>stacks_tip_height</code>) is 2 or more by checking http://localhost:3999/v2/info.
Initially, the server won't response.</p>
<p>For more detailed information about the progress you can look at <code>./logs.sh stacks-api</code>.
Wait until you see a message like <code>Proxy created: /  -&gt; http://stacks:20443</code></p>
<p>or</p>
<p>you can look at <code>./logs.sh stacks</code>.
There is a time after Clarity state genesis was computed without log messages. Just keep on waiting...
See the bitcoin blocks syncing and wait for messages like <code>Miner: mined anchored block ...</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-limitation"><a class="header" href="#known-limitation">Known Limitation</a></h1>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<ul>
<li>The sbtc wallet is managed by a central authority, not the set of stackers</li>
<li>Bitcoin can be deposited to a contract, however, contracts can initiate a withdrawal request. Withdrawal requests can be only submitted via the Bitcoin blockchain.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-10"><a class="header" href="#sbtc-10">sBTC 1.0</a></h1>
<p>TODO: <a href="https://github.com/stacks-network/sbtc-docs/issues/14">#14</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sbtc-11"><a class="header" href="#sbtc-11">sBTC 1.1</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
